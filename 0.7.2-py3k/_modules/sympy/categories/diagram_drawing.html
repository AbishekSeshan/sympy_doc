

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.categories.diagram_drawing &mdash; SymPy 0.7.2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.2 documentation" href="../../../index.html" />
    <link rel="up" title="sympy.categories" href="../../sympy/categories.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li>
          <li><a href="../../sympy/categories.html" accesskey="U">sympy.categories</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.categories.diagram_drawing</h1><div class="highlight"><pre>
<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">This module contains the functionality to arrange the nodes of a</span>
<span class="sd">diagram on an abstract grid, and then to produce a graphical</span>
<span class="sd">representation of the grid.</span>

<span class="sd">The currently supported back-ends are Xy-pic [Xypic].</span>

<span class="sd">Layout Algorithm</span>
<span class="sd">================</span>

<span class="sd">This section provides an overview of the algorithms implemented in</span>
<span class="sd">:class:`DiagramGrid` to lay out diagrams.</span>

<span class="sd">The first step of the algorithm is the removal composite and identity</span>
<span class="sd">morphisms which do not have properties in the supplied diagram.  The</span>
<span class="sd">premises and conclusions of the diagram are then merged.</span>

<span class="sd">The generic layout algorithm begins with the construction of the</span>
<span class="sd">&quot;skeleton&quot; of the diagram.  The skeleton is an undirected graph which</span>
<span class="sd">has the objects of the diagram as vertices and has an (undirected)</span>
<span class="sd">edge between each pair of objects between which there exist morphisms.</span>
<span class="sd">The direction of the morphisms does not matter at this stage.  The</span>
<span class="sd">skeleton also includes an edge between each pair of vertices `A` and</span>
<span class="sd">`C` such that there exists an object `B` which is connected via</span>
<span class="sd">a morphism to `A`, and via a morphism to `C`.</span>

<span class="sd">The skeleton constructed in this way has the property that every</span>
<span class="sd">object is a vertex of a triangle formed by three edges of the</span>
<span class="sd">skeleton.  This property lies at the base of the generic layout</span>
<span class="sd">algorithm.</span>

<span class="sd">After the skeleton has been constructed, the algorithm lists all</span>
<span class="sd">triangles which can be formed.  Note that some triangles will not have</span>
<span class="sd">all edges corresponding to morphisms which will actually be drawn.</span>
<span class="sd">Triangles which have only one edge or less which will actually be</span>
<span class="sd">drawn are immediately discarded.</span>

<span class="sd">The list of triangles is sorted according to the number of edges which</span>
<span class="sd">correspond to morphisms, then the triangle with the least number of such</span>
<span class="sd">edges is selected.  One of such edges is picked and the corresponding</span>
<span class="sd">objects are placed horizontally, on a grid.  This edge is recorded to</span>
<span class="sd">be in the fringe.  The algorithm then finds a &quot;welding&quot; of a triangle</span>
<span class="sd">to the fringe.  A welding is an edge in the fringe where a triangle</span>
<span class="sd">could be attached.  If the algorithm succeeds in finding such a</span>
<span class="sd">welding, it adds to the grid that vertex of the triangle which was not</span>
<span class="sd">yet included in any edge in the fringe and records the two new edges in</span>
<span class="sd">the fringe.  This process continues iteratively until all objects of</span>
<span class="sd">the diagram has been placed or until no more weldings can be found.</span>

<span class="sd">An edge is only removed from the fringe when a welding to this edge</span>
<span class="sd">has been found, and there is no room around this edge to place</span>
<span class="sd">another vertex.</span>

<span class="sd">When no more weldings can be found, but there are still triangles</span>
<span class="sd">left, the algorithm searches for a possibility of attaching one of the</span>
<span class="sd">remaining triangles to the existing structure by a vertex.  If such a</span>
<span class="sd">possibility is found, the corresponding edge of the found triangle is</span>
<span class="sd">placed in the found space and the iterative process of welding</span>
<span class="sd">triangles restarts.</span>

<span class="sd">When logical groups are supplied, each of these groups is laid out</span>
<span class="sd">independently.  Then a diagram is constructed in which groups are</span>
<span class="sd">objects and any two logical groups between which there exist morphisms</span>
<span class="sd">are connected via a morphism.  This diagram is laid out.  Finally,</span>
<span class="sd">the grid which includes all objects of the initial diagram is</span>
<span class="sd">constructed by replacing the cells which contain logical groups with</span>
<span class="sd">the corresponding laid out grids, and by correspondingly expanding the</span>
<span class="sd">rows and columns.</span>

<span class="sd">The sequential layout algorithm begins by constructing the</span>
<span class="sd">underlying undirected graph defined by the morphisms obtained after</span>
<span class="sd">simplifying premises and conclusions and merging them (see above).</span>
<span class="sd">The vertex with the minimal degree is then picked up and depth-first</span>
<span class="sd">search is started from it.  All objects which are located at distance</span>
<span class="sd">`n` from the root in the depth-first search tree, are positioned in</span>
<span class="sd">the `n`-th column of the resulting grid.  The sequential layout will</span>
<span class="sd">therefore attempt to lay the objects out along a line.</span>

<span class="sd">References</span>
<span class="sd">==========</span>

<span class="sd">[Xypic] http://www.tug.org/applications/Xy-pic/</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">sympy.categories</span> <span class="kn">import</span> <span class="p">(</span><span class="n">CompositeMorphism</span><span class="p">,</span> <span class="n">IdentityMorphism</span><span class="p">,</span>
                              <span class="n">NamedMorphism</span><span class="p">,</span> <span class="n">Diagram</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.utilities</span> <span class="kn">import</span> <span class="n">default_sort_key</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">iterable</span>

<span class="k">class</span> <span class="nc">_GrowableGrid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Holds a growable grid of objects.</span>

<span class="sd">    It is possible to append or prepend a row or a column to the grid</span>
<span class="sd">    using the corresponding methods.  Prepending rows or columns has</span>
<span class="sd">    the effect of changing the coordinates of the already existing</span>
<span class="sd">    elements.</span>

<span class="sd">    This class currently represents a naive implementation of the</span>
<span class="sd">    functionality with little attempt at optimisation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_height</span> <span class="o">=</span> <span class="n">height</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">height</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_width</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_height</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xxx_todo_changeme</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the element located at in the i-th line and j-th</span>
<span class="sd">        column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">xxx_todo_changeme</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xxx_todo_changeme1</span><span class="p">,</span> <span class="n">newvalue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the element located at in the i-th line and j-th</span>
<span class="sd">        column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">xxx_todo_changeme1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">newvalue</span>

    <span class="k">def</span> <span class="nf">append_row</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends an empty row to the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_height</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">None</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_width</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">append_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends an empty column to the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_height</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepend_row</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepends the grid with an empty row.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_height</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_width</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">prepend_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepends the grid with an empty column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_height</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

<div class="viewcode-block" id="DiagramGrid"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.DiagramGrid">[docs]</a><span class="k">class</span> <span class="nc">DiagramGrid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Constructs and holds the fitting of the diagram into a grid.</span>

<span class="sd">    The mission of this class is to analyse the structure of the</span>
<span class="sd">    supplied diagram and to place its objects on a grid such that,</span>
<span class="sd">    when the objects and the morphisms are actually drawn, the diagram</span>
<span class="sd">    would be &quot;readable&quot;, in the sense that there will not be many</span>
<span class="sd">    intersections of moprhisms.  This class does not perform any</span>
<span class="sd">    actual drawing.  It does strive nevertheless to offer sufficient</span>
<span class="sd">    metadata to draw a diagram.</span>

<span class="sd">    Consider the following simple diagram.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">    &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">    &gt;&gt;&gt; from sympy import pprint</span>
<span class="sd">    &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; diagram = Diagram([f, g])</span>

<span class="sd">    The simplest way to have a diagram laid out is the following:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">    &gt;&gt;&gt; (grid.width, grid.height)</span>
<span class="sd">    (2, 2)</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    A  B</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">       C</span>

<span class="sd">    Sometimes one sees the diagram as consisting of logical groups.</span>
<span class="sd">    One can advise ``DiagramGrid`` as to such groups by employing the</span>
<span class="sd">    ``groups`` keyword argument.</span>

<span class="sd">    Consider the following diagram:</span>

<span class="sd">    &gt;&gt;&gt; D = Object(&quot;D&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; h = NamedMorphism(D, A, &quot;h&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = NamedMorphism(D, B, &quot;k&quot;)</span>
<span class="sd">    &gt;&gt;&gt; diagram = Diagram([f, g, h, k])</span>

<span class="sd">    Lay it out with generic layout:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    A  B  D</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">       C</span>

<span class="sd">    Now, we can group the objects `A` and `D` to have them near one</span>
<span class="sd">    another:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram, groups=[[A, D], B, C])</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    B     C</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    A  D</span>

<span class="sd">    Note how the positioning of the other objects changes.</span>

<span class="sd">    Further indications can be supplied to the constructor of</span>
<span class="sd">    :class:`DiagramGrid` using keyword arguments.  The currently</span>
<span class="sd">    supported hints are explained in the following paragraphs.</span>

<span class="sd">    :class:`DiagramGrid` does not automatically guess which layout</span>
<span class="sd">    would suit the supplied diagram better.  Consider, for example,</span>
<span class="sd">    the following linear diagram:</span>

<span class="sd">    &gt;&gt;&gt; E = Object(&quot;E&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; h = NamedMorphism(C, D, &quot;h&quot;)</span>
<span class="sd">    &gt;&gt;&gt; i = NamedMorphism(D, E, &quot;i&quot;)</span>
<span class="sd">    &gt;&gt;&gt; diagram = Diagram([f, g, h, i])</span>

<span class="sd">    When laid out with the generic layout, it does not get to look</span>
<span class="sd">    linear:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    A  B</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">       C  D</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">          E</span>

<span class="sd">    To get it laid out in a line, use ``layout=&quot;sequential&quot;``:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram, layout=&quot;sequential&quot;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    A  B  C  D  E</span>

<span class="sd">    One may sometimes need to transpose the resulting layout.  While</span>
<span class="sd">    this can always be done by hand, :class:`DiagramGrid` provides a</span>
<span class="sd">    hint for that purpose:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram, layout=&quot;sequential&quot;, transpose=True)</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    A</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    B</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    C</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    D</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    E</span>

<span class="sd">    Separate hints can also be provided for each group.  For an</span>
<span class="sd">    example, refer to ``tests/test_drawing.py``, and see the different</span>
<span class="sd">    ways in which the five lemma [FiveLemma] can be laid out.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    Diagram</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>
<span class="sd">    [FiveLemma] http://en.wikipedia.org/wiki/Five_lemma</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_simplify_morphisms</span><span class="p">(</span><span class="n">morphisms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a dictionary mapping morphisms to their properties,</span>
<span class="sd">        returns a new dictionary in which there are no morphisms which</span>
<span class="sd">        do not have properties, and which are compositions of other</span>
<span class="sd">        morphisms included in the dictionary.  Identities are dropped</span>
<span class="sd">        as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newmorphisms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">props</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">morphisms</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">CompositeMorphism</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">props</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">IdentityMorphism</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newmorphisms</span><span class="p">[</span><span class="n">morphism</span><span class="p">]</span> <span class="o">=</span> <span class="n">props</span>
        <span class="k">return</span> <span class="n">newmorphisms</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_merge_premises_conclusions</span><span class="p">(</span><span class="n">premises</span><span class="p">,</span> <span class="n">conclusions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given two dictionaries of morphisms and their properties,</span>
<span class="sd">        produces a single dictionary which includes elements from both</span>
<span class="sd">        dictionaries.  If a morphism has some properties in premises</span>
<span class="sd">        and also in conclusions, the properties in conclusions take</span>
<span class="sd">        priority.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">premises</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="nb">list</span><span class="p">(</span><span class="n">conclusions</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_juxtapose_edges</span><span class="p">(</span><span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If ``edge1`` and ``edge2`` have precisely one common endpoint,</span>
<span class="sd">        returns an edge which would form a triangle with ``edge1`` and</span>
<span class="sd">        ``edge2``.</span>

<span class="sd">        If ``edge1`` and ``edge2`` don&#39;t have a common endpoint,</span>
<span class="sd">        returns ``None``.</span>

<span class="sd">        If ``edge1`` and ``edge`` are the same edge, returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="n">edge1</span> <span class="o">&amp;</span> <span class="n">edge2</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># The edges either have no common points or are equal.</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># The edges have a common endpoint.  Extract the different</span>
        <span class="c"># endpoints and set up the new edge.</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">edge1</span> <span class="o">-</span> <span class="n">intersection</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">edge2</span> <span class="o">-</span> <span class="n">intersection</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_edge_append</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If ``edge`` is not in ``dictionary``, adds ``edge`` to the</span>
<span class="sd">        dictionary and sets its value to ``[elem]``.  Otherwise</span>
<span class="sd">        appends ``elem`` to the value of existing entry.</span>

<span class="sd">        Note that edges are undirected, thus `(A, B) = (B, A)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_build_skeleton</span><span class="p">(</span><span class="n">morphisms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dictionary which maps edges to corresponding</span>
<span class="sd">        morphisms.  Thus for a morphism `f:A\rightarrow B`, the edge</span>
<span class="sd">        `(A, B)` will be associated with `f`.  This function also adds</span>
<span class="sd">        to the list those edges which are formed by juxtaposition of</span>
<span class="sd">        two edges already in the list.  These new edges are not</span>
<span class="sd">        associated with any morphism and are only added to assure that</span>
<span class="sd">        the diagram can be decomposed into triangles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># Create edges for morphisms.</span>
        <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">morphisms</span><span class="p">:</span>
            <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_add_edge_append</span><span class="p">(</span>
                <span class="n">edges</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">]),</span> <span class="n">morphism</span><span class="p">)</span>

        <span class="c"># Create new edges by juxtaposing existing edges.</span>
        <span class="n">edges1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges1</span><span class="p">:</span>
                <span class="n">wv</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_juxtapose_edges</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">wv</span> <span class="ow">and</span> <span class="n">wv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                    <span class="n">edges</span><span class="p">[</span><span class="n">wv</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">edges</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_list_triangles</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds the set of triangles formed by the supplied edges.  The</span>
<span class="sd">        triangles are arbitrary and need not be commutative.  A</span>
<span class="sd">        triangle is a set that contains all three of its sides.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">wv</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_juxtapose_edges</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">wv</span> <span class="ow">and</span> <span class="n">wv</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                    <span class="n">triangles</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">wv</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">triangles</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_drop_redundant_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list which contains only those triangles who have</span>
<span class="sd">        morphisms associated with at least two edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tri</span> <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">triangles</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tri</span> <span class="k">if</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">e</span><span class="p">]])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_morphism_length</span><span class="p">(</span><span class="n">morphism</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length of a morphism.  The length of a morphism is</span>
<span class="sd">        the number of components it consists of.  A non-composite</span>
<span class="sd">        morphism is of length 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">CompositeMorphism</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_compute_triangle_min_sizes</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary mapping triangles to their minimal sizes.</span>
<span class="sd">        The minimal size of a triangle is the sum of maximal lengths</span>
<span class="sd">        of morphisms associated to the sides of the triangle.  The</span>
<span class="sd">        length of a morphism is the number of components it consists</span>
<span class="sd">        of.  A non-composite morphism is of length 1.</span>

<span class="sd">        Sorting triangles by this metric attempts to address two</span>
<span class="sd">        aspects of layout.  For triangles with only simple morphisms</span>
<span class="sd">        in the edge, this assures that triangles with all three edges</span>
<span class="sd">        visible will get typeset after triangles with less visible</span>
<span class="sd">        edges, which sometimes minimises the necessity in diagonal</span>
<span class="sd">        arrows.  For triangles with composite morphisms in the edges,</span>
<span class="sd">        this assures that objects connected with shorter morphisms</span>
<span class="sd">        will be laid out first, resulting the visual proximity of</span>
<span class="sd">        those objects which are connected by shorter morphisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">triangle_sizes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">triangle</span><span class="p">:</span>
                <span class="n">morphisms</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">morphisms</span><span class="p">:</span>
                    <span class="n">size</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_morphism_length</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">morphisms</span><span class="p">)</span>
            <span class="n">triangle_sizes</span><span class="p">[</span><span class="n">triangle</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">return</span> <span class="n">triangle_sizes</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_triangle_objects</span><span class="p">(</span><span class="n">triangle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a triangle, returns the objects included in it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># A triangle is a frozenset of three two-element frozensets</span>
        <span class="c"># (the edges).  This chains the three edges together and</span>
        <span class="c"># creates a frozenset from the iterator, thus producing a</span>
        <span class="c"># frozenset of objects of the triangle.</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">triangle</span><span class="p">)))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_other_vertex</span><span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a triangle and an edge of it, returns the vertex which</span>
<span class="sd">        opposes the edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># This gets the set of objects of the triangle and then</span>
        <span class="c"># subtracts the set of objects employed in ``edge`` to get the</span>
        <span class="c"># vertex opposite to ``edge``.</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_objects</span><span class="p">(</span><span class="n">triangle</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">edge</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_empty_point</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the cell at coordinates ``pt`` is either empty or</span>
<span class="sd">        out of the bounds of the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_put_object</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">fringe</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Places an object at the coordinate ``cords`` in ``grid``,</span>
<span class="sd">        growing the grid and updating ``fringe``, if necessary.</span>
<span class="sd">        Returns (0, 0) if no row or column has been prepended, (1, 0)</span>
<span class="sd">        if a row was prepended, (0, 1) if a column was prepended and</span>
<span class="sd">        (1, 1) if both a column and a row were prepended.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">prepend_row</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fringe</span><span class="p">)):</span>
                <span class="p">((</span><span class="n">i1</span><span class="p">,</span> <span class="n">j1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">))</span> <span class="o">=</span> <span class="n">fringe</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">fringe</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">append_row</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">prepend_column</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fringe</span><span class="p">)):</span>
                <span class="p">((</span><span class="n">i1</span><span class="p">,</span> <span class="n">j1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">))</span> <span class="o">=</span> <span class="n">fringe</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">fringe</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">i1</span><span class="p">,</span> <span class="n">j1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">append_column</span><span class="p">()</span>

        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">return</span> <span class="n">offset</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_choose_target_cell</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given two points, ``pt1`` and ``pt2``, and the welding edge</span>
<span class="sd">        ``edge``, chooses one of the two points to place the opposing</span>
<span class="sd">        vertex ``obj`` of the triangle.  If neither of this points</span>
<span class="sd">        fits, returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pt1_empty</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_empty_point</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="n">pt2_empty</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_empty_point</span><span class="p">(</span><span class="n">pt2</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pt1_empty</span> <span class="ow">and</span> <span class="n">pt2_empty</span><span class="p">:</span>
            <span class="c"># Both cells are empty.  Of these two, choose that cell</span>
            <span class="c"># which will assure that a visible edge of the triangle</span>
            <span class="c"># will be drawn perpendicularly to the current welding</span>
            <span class="c"># edge.</span>

            <span class="n">A</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">obj</span><span class="p">])):</span>
                <span class="k">return</span> <span class="n">pt1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pt2</span>
        <span class="k">if</span> <span class="n">pt1_empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pt1</span>
        <span class="k">elif</span> <span class="n">pt2_empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pt2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_triangle_to_weld</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds, if possible, a triangle and an edge in the fringe to</span>
<span class="sd">        which the triangle could be attached.  Returns the tuple</span>
<span class="sd">        containing the triangle and the index of the corresponding</span>
<span class="sd">        edge in the fringe.</span>

<span class="sd">        This function relies on the fact that objects are unique in</span>
<span class="sd">        the diagram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">fringe</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">grid</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="n">b</span><span class="p">]])</span> <span class="ow">in</span> <span class="n">triangle</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_weld_triangle</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">welding_edge</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If possible, welds the triangle ``tri`` to ``fringe`` and</span>
<span class="sd">        returns ``False``.  If this method encounters a degenerate</span>
<span class="sd">        situation in the fringe and corrects it such that a restart of</span>
<span class="sd">        the search is required, it returns ``True`` (which means that</span>
<span class="sd">        a restart in finding triangle weldings is required).</span>

<span class="sd">        A degenerate situation is a situation when an edge listed in</span>
<span class="sd">        the fringe does not belong to the visual boundary of the</span>
<span class="sd">        diagram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">welding_edge</span>
        <span class="n">target_cell</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_other_vertex</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="n">b</span><span class="p">]))</span>

        <span class="c"># We now have a triangle and an edge where it can be welded to</span>
        <span class="c"># the fringe.  Decide where to place the other vertex of the</span>
        <span class="c"># triangle and check for degenerate situations en route.</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c"># A diagonal edge.</span>
            <span class="n">target_cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">target_cell</span><span class="p">]:</span>
                <span class="c"># That cell is already occupied.</span>
                <span class="n">target_cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">target_cell</span><span class="p">]:</span>
                    <span class="c"># Degenerate situation, this edge is not</span>
                    <span class="c"># on the actual fringe.  Correct the</span>
                    <span class="c"># fringe and go on.</span>
                    <span class="n">fringe</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                    <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c"># A horizontal edge.  We first attempt to build the</span>
            <span class="c"># triangle in the downward direction.</span>

            <span class="n">down_left</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">down_right</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">target_cell</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_choose_target_cell</span><span class="p">(</span>
                <span class="n">down_left</span><span class="p">,</span> <span class="n">down_right</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">obj</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">target_cell</span><span class="p">:</span>
                <span class="c"># No room below this edge.  Check above.</span>
                <span class="n">up_left</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">up_right</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">target_cell</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_choose_target_cell</span><span class="p">(</span>
                    <span class="n">up_left</span><span class="p">,</span> <span class="n">up_right</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">obj</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">target_cell</span><span class="p">:</span>
                    <span class="c"># This edge is not in the fringe, remove it</span>
                    <span class="c"># and restart.</span>
                    <span class="n">fringe</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                    <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c"># A vertical edge.  We will attempt to place the other</span>
            <span class="c"># vertex of the triangle to the right of this edge.</span>
            <span class="n">right_up</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">right_down</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">target_cell</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_choose_target_cell</span><span class="p">(</span>
                <span class="n">right_up</span><span class="p">,</span> <span class="n">right_down</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">obj</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">target_cell</span><span class="p">:</span>
                <span class="c"># No room to the left.  See what&#39;s to the right.</span>
                <span class="n">left_up</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">left_down</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="n">target_cell</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_choose_target_cell</span><span class="p">(</span>
                    <span class="n">left_up</span><span class="p">,</span> <span class="n">left_down</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">obj</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">target_cell</span><span class="p">:</span>
                    <span class="c"># This edge is not in the fringe, remove it</span>
                    <span class="c"># and restart.</span>
                    <span class="n">fringe</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                    <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># We now know where to place the other vertex of the</span>
        <span class="c"># triangle.</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_put_object</span><span class="p">(</span><span class="n">target_cell</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">fringe</span><span class="p">)</span>

        <span class="c"># Take care of the displacement of coordinates if a row or</span>
        <span class="c"># a column was prepended.</span>
        <span class="n">target_cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                       <span class="n">target_cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">fringe</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">target_cell</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">target_cell</span><span class="p">)])</span>

        <span class="c"># No restart is required.</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_triangle_key</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">triangle_sizes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a key for the supplied triangle.  It should be the</span>
<span class="sd">        same independently of the hash randomisation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_objects</span><span class="p">(</span><span class="n">tri</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">triangle_sizes</span><span class="p">[</span><span class="n">tri</span><span class="p">],</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">objects</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pick_root_edge</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a given triangle always picks the same root edge.  The</span>
<span class="sd">        root edge is the edge that will be placed first on the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tri</span> <span class="k">if</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">e</span><span class="p">]]</span>
        <span class="n">sorted_candidates</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
        <span class="c"># Don&#39;t forget to assure the proper ordering of the vertices</span>
        <span class="c"># in this edge.</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">sorted_candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_drop_irrelevant_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns only those triangles whose set of objects is not</span>
<span class="sd">        completely included in ``placed_objects``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tri</span> <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">triangles</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">placed_objects</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span>
            <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_objects</span><span class="p">(</span><span class="n">tri</span><span class="p">))]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_grow_pseudopod</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starting from an object in the existing structure on the grid,</span>
<span class="sd">        adds an edge to which a triangle from ``triangles`` could be</span>
<span class="sd">        welded.  If this method has found a way to do so, it returns</span>
<span class="sd">        the object it has just added.</span>

<span class="sd">        This method should be applied when ``_weld_triangle`` cannot</span>
<span class="sd">        find weldings any more.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c"># Here we need to choose a triangle which has only</span>
                <span class="c"># ``obj`` in common with the existing structure.  The</span>
                <span class="c"># situations when this is not possible should be</span>
                <span class="c"># handled elsewhere.</span>

                <span class="k">def</span> <span class="nf">good_triangle</span><span class="p">(</span><span class="n">tri</span><span class="p">):</span>
                    <span class="n">objs</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_objects</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span> <span class="ow">and</span> \
                           <span class="n">placed_objects</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">objs</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">obj</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">()</span>

                <span class="n">tris</span> <span class="o">=</span> <span class="p">[</span><span class="n">tri</span> <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">triangles</span> <span class="k">if</span> <span class="n">good_triangle</span><span class="p">(</span><span class="n">tri</span><span class="p">)]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tris</span><span class="p">:</span>
                    <span class="c"># This object is not interesting.</span>
                    <span class="k">continue</span>

                <span class="c"># Pick the &quot;simplest&quot; of the triangles which could be</span>
                <span class="c"># attached.  Remember that the list of triangles is</span>
                <span class="c"># sorted according to their &quot;simplicity&quot; (see</span>
                <span class="c"># _compute_triangle_min_sizes for the metric).</span>
                <span class="c">#</span>
                <span class="c"># Note that ``tris`` are sequentially built from</span>
                <span class="c"># ``triangles``, so we don&#39;t have to worry about hash</span>
                <span class="c"># randomisation.</span>
                <span class="n">tri</span> <span class="o">=</span> <span class="n">tris</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c"># We have found a triangle which could be attached to</span>
                <span class="c"># the existing structure by a vertex.</span>

                <span class="n">candidates</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tri</span> <span class="k">if</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">e</span><span class="p">]],</span>
                                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>

                <span class="c"># Note that a meaningful edge (i.e., and edge that is</span>
                <span class="c"># associated with a morphism) containing ``obj``</span>
                <span class="c"># always exists.  That&#39;s because all triangles are</span>
                <span class="c"># guaranteed to have at least two meaningful edges.</span>
                <span class="c"># See _drop_redundant_triangles.</span>

                <span class="c"># Get the object at the other end of the edge.</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">other_obj</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge</span> <span class="o">-</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">obj</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c"># Now check for free directions.  When checking for</span>
                <span class="c"># free directions, prefer the horizontal and vertical</span>
                <span class="c"># directions.</span>
                <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_empty_point</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
                        <span class="c"># We have a found a place to grow the</span>
                        <span class="c"># pseudopod into.</span>
                        <span class="n">offset</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_put_object</span><span class="p">(</span>
                            <span class="n">pt</span><span class="p">,</span> <span class="n">other_obj</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">fringe</span><span class="p">)</span>

                        <span class="n">i</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">j</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">fringe</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">pt</span><span class="p">))</span>

                        <span class="k">return</span> <span class="n">other_obj</span>

        <span class="c"># This diagram is actually cooler that I can handle.  Fail cowardly.</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_handle_groups</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">,</span> <span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the slightly preprocessed morphisms of the diagram,</span>
<span class="sd">        produces a grid laid out according to ``groups``.</span>

<span class="sd">        If a group has hints, it is laid out with those hints only,</span>
<span class="sd">        without any influence from ``hints``.  Otherwise, it is laid</span>
<span class="sd">        out with ``hints``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">lay_out_group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">local_hints</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            If ``group`` is a set of objects, uses a ``DiagramGrid``</span>
<span class="sd">            to lay it out and returns the grid.  Otherwise returns the</span>
<span class="sd">            object (i.e., ``group``).  If ``local_hints`` is not</span>
<span class="sd">            empty, it is supplied to ``DiagramGrid`` as the dictionary</span>
<span class="sd">            of hints.  Otherwise, the ``hints`` argument of</span>
<span class="sd">            ``_handle_groups`` is used.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">):</span>
                <span class="c"># Set up the corresponding object-to-group</span>
                <span class="c"># mappings.</span>
                <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                    <span class="n">obj_groups</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>

                <span class="c"># Lay out the current group.</span>
                <span class="k">if</span> <span class="n">local_hints</span><span class="p">:</span>
                    <span class="n">groups_grids</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span>
                        <span class="n">diagram</span><span class="o">.</span><span class="n">subdiagram_from_objects</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="o">**</span><span class="n">local_hints</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">groups_grids</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span>
                        <span class="n">diagram</span><span class="o">.</span><span class="n">subdiagram_from_objects</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj_groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>

        <span class="k">def</span> <span class="nf">group_to_finiteset</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Converts ``group`` to a :class:``FiniteSet`` if it is an</span>
<span class="sd">            iterable.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">group</span>

        <span class="n">obj_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">groups_grids</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># We would like to support various containers to represent</span>
        <span class="c"># groups.  To achieve that, before laying each group out, it</span>
        <span class="c"># should be converted to a FiniteSet, because that is what the</span>
        <span class="c"># following code expects.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">Dict</span><span class="p">):</span>
            <span class="n">finiteset_groups</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">local_hints</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">finiteset_group</span> <span class="o">=</span> <span class="n">group_to_finiteset</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="n">finiteset_groups</span><span class="p">[</span><span class="n">finiteset_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_hints</span>
                <span class="n">lay_out_group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">local_hints</span><span class="p">)</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">finiteset_groups</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">finiteset_groups</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="n">finiteset_group</span> <span class="o">=</span> <span class="n">group_to_finiteset</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="n">finiteset_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">finiteset_group</span><span class="p">)</span>
                <span class="n">lay_out_group</span><span class="p">(</span><span class="n">finiteset_group</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">finiteset_groups</span>

        <span class="n">new_morphisms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">merged_morphisms</span><span class="p">:</span>
            <span class="n">dom</span> <span class="o">=</span> <span class="n">obj_groups</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
            <span class="n">cod</span> <span class="o">=</span> <span class="n">obj_groups</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>
            <span class="c"># Note that we are not really interested in morphisms</span>
            <span class="c"># which do not employ two different groups, because</span>
            <span class="c"># these do not influence the layout.</span>
            <span class="k">if</span> <span class="n">dom</span> <span class="o">!=</span> <span class="n">cod</span><span class="p">:</span>
                <span class="c"># These are essentially unnamed morphisms; they are</span>
                <span class="c"># not going to mess in the final layout.  By giving</span>
                <span class="c"># them the same names, we avoid unnecessary</span>
                <span class="c"># duplicates.</span>
                <span class="n">new_morphisms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NamedMorphism</span><span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="n">cod</span><span class="p">,</span> <span class="s">&quot;dummy&quot;</span><span class="p">))</span>

        <span class="c"># Lay out the new diagram.  Since these are dummy morphisms,</span>
        <span class="c"># properties and conclusions are irrelevant.</span>
        <span class="n">top_grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span><span class="n">Diagram</span><span class="p">(</span><span class="n">new_morphisms</span><span class="p">))</span>

        <span class="c"># We now have to substitute the groups with the corresponding</span>
        <span class="c"># grids, laid out at the beginning of this function.  Compute</span>
        <span class="c"># the size of each row and column in the grid, so that all</span>
        <span class="c"># nested grids fit.</span>

        <span class="k">def</span> <span class="nf">group_size</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            For the supplied group (or object, eventually), returns</span>
<span class="sd">            the size of the cell that will hold this group (object).</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups_grids</span><span class="p">:</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">groups_grids</span><span class="p">[</span><span class="n">group</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">row_heights</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">group_size</span><span class="p">(</span><span class="n">top_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                           <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">height</span><span class="p">)]</span>

        <span class="n">column_widths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">group_size</span><span class="p">(</span><span class="n">top_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">height</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">width</span><span class="p">)]</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">column_widths</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">row_heights</span><span class="p">))</span>

        <span class="n">real_row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">real_column</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">logical_row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">logical_column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">top_grid</span><span class="p">[</span><span class="n">logical_row</span><span class="p">,</span> <span class="n">logical_column</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">groups_grids</span><span class="p">:</span>
                    <span class="c"># This is a group.  Copy the corresponding grid in</span>
                    <span class="c"># place.</span>
                    <span class="n">local_grid</span> <span class="o">=</span> <span class="n">groups_grids</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">local_grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">local_grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                            <span class="n">grid</span><span class="p">[</span><span class="n">real_row</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">real_column</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># This is an object.  Just put it there.</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">real_row</span><span class="p">,</span> <span class="n">real_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

                <span class="n">real_column</span> <span class="o">+=</span> <span class="n">column_widths</span><span class="p">[</span><span class="n">logical_column</span><span class="p">]</span>
            <span class="n">real_column</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">real_row</span> <span class="o">+=</span> <span class="n">row_heights</span><span class="p">[</span><span class="n">logical_row</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">grid</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generic_layout</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces the generic layout for the supplied diagram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_objects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">diagram</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_objects</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># There only one object in the diagram, just put in on 1x1</span>
            <span class="c"># grid.</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">all_objects</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">grid</span>

        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_build_skeleton</span><span class="p">(</span><span class="n">merged_morphisms</span><span class="p">)</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># This diagram contains only one morphism.  Draw it</span>
            <span class="c"># horizontally.</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_objects</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">grid</span>

        <span class="n">triangles</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_list_triangles</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_drop_redundant_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">)</span>
        <span class="n">triangle_sizes</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_compute_triangle_min_sizes</span><span class="p">(</span>
            <span class="n">triangles</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">)</span>

        <span class="n">triangles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tri</span><span class="p">:</span>
                           <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_key</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">triangle_sizes</span><span class="p">))</span>

        <span class="c"># Place the first edge on the grid.</span>
        <span class="n">root_edge</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_pick_root_edge</span><span class="p">(</span><span class="n">triangles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">skeleton</span><span class="p">)</span>
        <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_edge</span>
        <span class="n">fringe</span> <span class="o">=</span> <span class="p">[((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))]</span>

        <span class="c"># Record which objects we now have on the grid.</span>
        <span class="n">placed_objects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">root_edge</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">placed_objects</span> <span class="o">!=</span> <span class="n">all_objects</span><span class="p">:</span>
            <span class="n">welding</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_find_triangle_to_weld</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">welding</span><span class="p">:</span>
                <span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="n">welding_edge</span><span class="p">)</span> <span class="o">=</span> <span class="n">welding</span>

                <span class="n">restart_required</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_weld_triangle</span><span class="p">(</span>
                    <span class="n">triangle</span><span class="p">,</span> <span class="n">welding_edge</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">restart_required</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">placed_objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_objects</span><span class="p">(</span><span class="n">triangle</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># No more weldings found.  Try to attach triangles by</span>
                <span class="c"># vertices.</span>
                <span class="n">new_obj</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_grow_pseudopod</span><span class="p">(</span>
                    <span class="n">triangles</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_obj</span><span class="p">:</span>
                    <span class="c"># No more triangles can be attached, not even by</span>
                    <span class="c"># the edge.  We will set up a new diagram out of</span>
                    <span class="c"># what has been left, laid it out independently,</span>
                    <span class="c"># and then attach it to this one.</span>

                    <span class="n">remaining_objects</span> <span class="o">=</span> <span class="n">all_objects</span> <span class="o">-</span> <span class="n">placed_objects</span>

                    <span class="n">remaining_diagram</span> <span class="o">=</span> <span class="n">diagram</span><span class="o">.</span><span class="n">subdiagram_from_objects</span><span class="p">(</span>
                        <span class="n">FiniteSet</span><span class="p">(</span><span class="n">remaining_objects</span><span class="p">))</span>
                    <span class="n">remaining_grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span><span class="n">remaining_diagram</span><span class="p">)</span>

                    <span class="c"># Now, let&#39;s glue ``remaining_grid`` to ``grid``.</span>
                    <span class="n">final_width</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span> <span class="o">+</span> <span class="n">remaining_grid</span><span class="o">.</span><span class="n">width</span>
                    <span class="n">final_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">remaining_grid</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
                    <span class="n">final_grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="n">final_width</span><span class="p">,</span> <span class="n">final_height</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                            <span class="n">final_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                    <span class="n">start_j</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">remaining_grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">remaining_grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                            <span class="n">final_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">start_j</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                    <span class="k">return</span> <span class="n">final_grid</span>

                <span class="n">placed_objects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_obj</span><span class="p">)</span>

            <span class="n">triangles</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_drop_irrelevant_triangles</span><span class="p">(</span>
                <span class="n">triangles</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grid</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_undirected_graph</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the objects and the relevant morphisms of a diagram,</span>
<span class="sd">        returns the adjacency lists of the underlying undirected</span>
<span class="sd">        graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adjlists</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
            <span class="n">adjlists</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">merged_morphisms</span><span class="p">:</span>
            <span class="n">adjlists</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">)</span>
            <span class="n">adjlists</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

        <span class="c"># Assure that the objects in the adjacency list are always in</span>
        <span class="c"># the same order.</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">adjlists</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">adjlists</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">adjlists</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sequential_layout</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Lays out the diagram in &quot;sequential&quot; layout.  This method</span>
<span class="sd">        will attempt to produce a result as close to a line as</span>
<span class="sd">        possible.  For linear diagrams, the result will actually be a</span>
<span class="sd">        line.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="n">diagram</span><span class="o">.</span><span class="n">objects</span>
        <span class="n">sorted_objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="c"># Set up the adjacency lists of the underlying undirected</span>
        <span class="c"># graph of ``merged_morphisms``.</span>
        <span class="n">adjlists</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_get_undirected_graph</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">)</span>

        <span class="c"># Find an object with the minimal degree.  This is going to be</span>
        <span class="c"># the root.</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">sorted_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mindegree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adjlists</span><span class="p">[</span><span class="n">root</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">sorted_objects</span><span class="p">:</span>
            <span class="n">current_degree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adjlists</span><span class="p">[</span><span class="n">obj</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">current_degree</span> <span class="o">&lt;</span> <span class="n">mindegree</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">obj</span>
                <span class="n">mindegree</span> <span class="o">=</span> <span class="n">current_degree</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>

        <span class="n">placed_objects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="k">def</span> <span class="nf">place_objects</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Does depth-first search in the underlying graph of the</span>
<span class="sd">            diagram and places the objects en route.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c"># We will start placing new objects from here.</span>
            <span class="n">new_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">adjacent_obj</span> <span class="ow">in</span> <span class="n">adjlists</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">pt</span><span class="p">]]:</span>
                <span class="k">if</span> <span class="n">adjacent_obj</span> <span class="ow">in</span> <span class="n">placed_objects</span><span class="p">:</span>
                    <span class="c"># This object has already been placed.</span>
                    <span class="k">continue</span>

                <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_put_object</span><span class="p">(</span><span class="n">new_pt</span><span class="p">,</span> <span class="n">adjacent_obj</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="p">[])</span>
                <span class="n">placed_objects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">adjacent_obj</span><span class="p">)</span>
                <span class="n">placed_objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">place_objects</span><span class="p">(</span><span class="n">new_pt</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">))</span>

                <span class="n">new_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">placed_objects</span>

        <span class="n">place_objects</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">placed_objects</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grid</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_drop_inessential_morphisms</span><span class="p">(</span><span class="n">merged_morphisms</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Removes those morphisms which should appear in the diagram,</span>
<span class="sd">        but which have no relevance to object layout.</span>

<span class="sd">        Currently this removes &quot;loop&quot; morphisms: the non-identity</span>
<span class="sd">        morphisms with the same domains and codomains.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">morphisms</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">merged_morphisms</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">morphisms</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_connected_components</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a container of morphisms, returns a list of connected</span>
<span class="sd">        components formed by these morphisms.  A connected component</span>
<span class="sd">        is represented by a diagram consisting of the corresponding</span>
<span class="sd">        morphisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">component_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
            <span class="n">component_index</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Get the underlying undirected graph of the diagram.</span>
        <span class="n">adjlist</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_get_undirected_graph</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">traverse_component</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">current_index</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Does a depth-first search traversal of the component</span>
<span class="sd">            containing ``object``.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">component_index</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_index</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">adjlist</span><span class="p">[</span><span class="nb">object</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">component_index</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">traverse_component</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">current_index</span><span class="p">)</span>

        <span class="c"># Traverse all components.</span>
        <span class="n">current_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">adjlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">component_index</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">traverse_component</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">current_index</span><span class="p">)</span>
                <span class="n">current_index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># List the objects of the components.</span>
        <span class="n">component_objects</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">current_index</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">component_index</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">component_objects</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="c"># Finally, list the morphisms belonging to each component.</span>
        <span class="c">#</span>
        <span class="c"># Note: If some objects are isolated, they will not get any</span>
        <span class="c"># morphisms at this stage, and since the layout algorithm</span>
        <span class="c"># relies, we are essentially going to lose this object.</span>
        <span class="c"># Therefore, check if there are isolated objects and, for each</span>
        <span class="c"># of them, provide the trivial identity morphism.  It will get</span>
        <span class="c"># discarded later, but the object will be there.</span>

        <span class="n">component_morphisms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">component_objects</span><span class="p">:</span>
            <span class="n">current_morphisms</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">merged_morphisms</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="n">component</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span> <span class="ow">in</span> <span class="n">component</span><span class="p">):</span>
                    <span class="n">current_morphisms</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_morphisms</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># Let&#39;s add an identity morphism, for the sake of</span>
                <span class="c"># surely having morphisms in this component.</span>
                <span class="n">current_morphisms</span><span class="p">[</span><span class="n">IdentityMorphism</span><span class="p">(</span><span class="n">component</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">FiniteSet</span><span class="p">()</span>

            <span class="n">component_morphisms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Diagram</span><span class="p">(</span><span class="n">current_morphisms</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">component_morphisms</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagram</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="n">premises</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_simplify_morphisms</span><span class="p">(</span><span class="n">diagram</span><span class="o">.</span><span class="n">premises</span><span class="p">)</span>
        <span class="n">conclusions</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_simplify_morphisms</span><span class="p">(</span><span class="n">diagram</span><span class="o">.</span><span class="n">conclusions</span><span class="p">)</span>
        <span class="n">all_merged_morphisms</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_merge_premises_conclusions</span><span class="p">(</span>
            <span class="n">premises</span><span class="p">,</span> <span class="n">conclusions</span><span class="p">)</span>
        <span class="n">merged_morphisms</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_drop_inessential_morphisms</span><span class="p">(</span>
            <span class="n">all_merged_morphisms</span><span class="p">)</span>

        <span class="c"># Store the merged morphisms for later use.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_morphisms</span> <span class="o">=</span> <span class="n">all_merged_morphisms</span>

        <span class="n">components</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_get_connected_components</span><span class="p">(</span>
            <span class="n">diagram</span><span class="o">.</span><span class="n">objects</span><span class="p">,</span> <span class="n">all_merged_morphisms</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">groups</span> <span class="ow">and</span> <span class="p">(</span><span class="n">groups</span> <span class="o">!=</span> <span class="n">diagram</span><span class="o">.</span><span class="n">objects</span><span class="p">):</span>
            <span class="c"># Lay out the diagram according to the groups.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_handle_groups</span><span class="p">(</span>
                <span class="n">diagram</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">,</span> <span class="n">hints</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># Note that we check for connectedness _before_ checking</span>
            <span class="c"># the layout hints because the layout strategies don&#39;t</span>
            <span class="c"># know how to deal with disconnected diagrams.</span>

            <span class="c"># The diagram is disconnected.  Lay out the components</span>
            <span class="c"># independently.</span>
            <span class="n">grids</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c"># Sort the components to eventually get the grids arranged</span>
            <span class="c"># in a fixed, hash-independent order.</span>
            <span class="n">components</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                <span class="n">grids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

            <span class="c"># Throw the grids together, in a line.</span>
            <span class="n">total_width</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">)</span>
            <span class="n">total_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">height</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">)</span>

            <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="n">total_width</span><span class="p">,</span> <span class="n">total_height</span><span class="p">)</span>
            <span class="n">start_j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">start_j</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                <span class="n">start_j</span> <span class="o">+=</span> <span class="n">g</span><span class="o">.</span><span class="n">width</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">elif</span> <span class="s">&quot;layout&quot;</span> <span class="ow">in</span> <span class="n">hints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hints</span><span class="p">[</span><span class="s">&quot;layout&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;sequential&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_sequential_layout</span><span class="p">(</span>
                    <span class="n">diagram</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_generic_layout</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;transpose&quot;</span><span class="p">):</span>
            <span class="c"># Transpose the resulting grid.</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">grid</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="DiagramGrid.width"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.DiagramGrid.width">[docs]</a>    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of columns in this diagram layout.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">        &gt;&gt;&gt; grid.width</span>
<span class="sd">        2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">width</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="DiagramGrid.height"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.DiagramGrid.height">[docs]</a>    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of rows in this diagram layout.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">        &gt;&gt;&gt; grid.height</span>
<span class="sd">        2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">height</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xxx_todo_changeme2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the object placed in the row ``i`` and column ``j``.</span>
<span class="sd">        The indices are 0-based.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">        &gt;&gt;&gt; (grid[0, 0], grid[0, 1])</span>
<span class="sd">        (Object(&quot;A&quot;), Object(&quot;B&quot;))</span>
<span class="sd">        &gt;&gt;&gt; (grid[1, 0], grid[1, 1])</span>
<span class="sd">        (None, Object(&quot;C&quot;))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">xxx_todo_changeme2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="DiagramGrid.morphisms"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.DiagramGrid.morphisms">[docs]</a>    <span class="k">def</span> <span class="nf">morphisms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns those morphisms (and their properties) which are</span>
<span class="sd">        sufficiently meaningful to be drawn.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">        &gt;&gt;&gt; grid.morphisms</span>
<span class="sd">        {NamedMorphism(Object(&quot;A&quot;), Object(&quot;B&quot;), &quot;f&quot;): EmptySet(),</span>
<span class="sd">        NamedMorphism(Object(&quot;B&quot;), Object(&quot;C&quot;), &quot;g&quot;): EmptySet()}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphisms</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces a string representation of this class.</span>

<span class="sd">        This method returns a string representation of the underlying</span>
<span class="sd">        list of lists of objects.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">        &gt;&gt;&gt; print(grid)</span>
<span class="sd">        [[Object(&quot;A&quot;), Object(&quot;B&quot;)],</span>
<span class="sd">        [None, Object(&quot;C&quot;)]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">_array</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li>
          <li><a href="../../sympy/categories.html" >sympy.categories</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, 2009, 2010, 2011, 2012 SymPy Development Team.
      Last updated on Jan 20, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>