

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.combinatorics.perm_groups &mdash; SymPy 0.7.1-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://59.sympy-live-tests.appspot.com//static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://59.sympy-live-tests.appspot.com//static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://59.sympy-live-tests.appspot.com//static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.1-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://59.sympy-live-tests.appspot.com//static/utilities.js"></script>
    <script type="text/javascript" src="http://59.sympy-live-tests.appspot.com//static/external/classy.js"></script>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
    <script type="text/javascript" src="http://59.sympy-live-tests.appspot.com//static/live-core.js"></script>
    <script type="text/javascript" src="http://59.sympy-live-tests.appspot.com//static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://59.sympy-live-tests.appspot.com//static/live-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.1-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy.combinatorics" href="../combinatorics.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.1-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li>
          <li><a href="../combinatorics.html" accesskey="U">sympy.combinatorics</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.combinatorics.perm_groups</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">sympy.combinatorics</span> <span class="kn">import</span> <span class="n">Permutation</span>
<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Basic</span>
<span class="kn">from</span> <span class="nn">sympy.combinatorics.permutations</span> <span class="kn">import</span> <span class="n">perm_af_mul</span><span class="p">,</span> \
 <span class="n">_new_from_array_form</span><span class="p">,</span> <span class="n">perm_af_commutes_with</span><span class="p">,</span> <span class="n">perm_af_invert</span><span class="p">,</span> <span class="n">perm_af_muln</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span><span class="p">,</span> <span class="n">choice</span>
<span class="kn">from</span> <span class="nn">sympy.functions.combinatorial.factorials</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="kn">import</span> <span class="n">isprime</span><span class="p">,</span> <span class="n">sieve</span>
<span class="kn">from</span> <span class="nn">sympy.combinatorics.util</span> <span class="kn">import</span> <span class="n">_check_cycles_alt_sym</span><span class="p">,</span>\
<span class="n">_distribute_gens_by_base</span><span class="p">,</span> <span class="n">_orbits_transversals_from_bsgs</span><span class="p">,</span>\
<span class="n">_handle_precomputed_bsgs</span><span class="p">,</span> <span class="n">_base_ordering</span><span class="p">,</span> <span class="n">_strong_gens_from_distr</span><span class="p">,</span> <span class="n">_strip</span>

<span class="k">def</span> <span class="nf">_smallest_change</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    find the smallest point not fixed by `h`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>

<span class="k">class</span> <span class="nc">_Vertex</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    vertex of JGraph</span>

<span class="sd">    neighbor list of neighbor vertices</span>
<span class="sd">    perm     list of permutations</span>
<span class="sd">    index_neighbor list of index position of vertices in neighbor</span>
<span class="sd">    if vertex j is a neighbor of vertex i, then</span>
<span class="sd">       vertex[i].index_neighbor[ vertex[i].neighbor[j] ] = j</span>
<span class="sd">    if vertex j is not a neighbor of vertex i,</span>
<span class="sd">    vertex[i].index_neighbor[j] = -1</span>
<span class="sd">    n size of permutation</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">neighbor</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">perm</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">index_neighbor</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

<span class="k">class</span> <span class="nc">_JGraph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jerrum graph</span>

<span class="sd">    vertex   vertices of the Jerrum graph for permutation group G &lt; S(n);</span>
<span class="sd">    vertex[i] i-th vertex, with `i` in range(n)</span>
<span class="sd">    jg       array of Jerrums generators (edges of the graph)</span>
<span class="sd">    jgs number of occupied entries of jg</span>
<span class="sd">    freejg   stack of slots of jg. freejg[i] points to the</span>
<span class="sd">             i-th free position of jg</span>
<span class="sd">    To a directed edge (i, j) between vertices i, j</span>
<span class="sd">    it is associated the index of a permutation `g` satisfying</span>
<span class="sd">    g[i] = j</span>
<span class="sd">    g = jg[vertex[i].perm[vertex[i].index_neighbor[j]]]</span>
<span class="sd">      = jg[vertex[j].perm[vertex[j].index_neighbor[i]]]</span>

<span class="sd">    cycle  list of indices of vertices used to identify cycles</span>
<span class="sd">    G Permutation group</span>
<span class="sd">    n size of permutation</span>
<span class="sd">    r number of generators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">_degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="p">[</span><span class="n">_Vertex</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">_generators</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jg</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jgs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freejg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cycle</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">_degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idn</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">prev</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        find if there is a cycle</span>

<span class="sd">        v      vertex from which start searching a cycle</span>
<span class="sd">        v1, v2 vertices through which the cycle must go</span>
<span class="sd">        prev   previous vertex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycle</span>
        <span class="n">neighbor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">neighbor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v1</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">neighbor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v2</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">:</span>
                <span class="n">cycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_cycle</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="n">cycle</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">neighbor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">:</span>
                <span class="n">cycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_cycle</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="n">cycle</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        insert permutation `g` in stabilizer chain at point alpha</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">idn</span><span class="p">:</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span>
            <span class="n">jg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jg</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">_smallest_change</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="n">ig</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index_neighbor</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nn</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># if ig is already neighbor of i</span>
                <span class="n">jginn</span> <span class="o">=</span> <span class="n">jg</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span><span class="n">nn</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">g</span> <span class="o">!=</span> <span class="n">jginn</span><span class="p">:</span>
                    <span class="c"># cycle consisting of two edges;</span>
                    <span class="c"># replace jginn by g and insert h = g**-1*jginn</span>
                    <span class="n">g1</span> <span class="o">=</span> <span class="n">perm_af_invert</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">perm_af_mul</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">jginn</span><span class="p">)</span>
                    <span class="n">jg</span><span class="p">[</span> <span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c"># new edge</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insert_edge</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ig</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cycle</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_cycle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ig</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycle</span>
                    <span class="n">cycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="c"># find the smallest point (vertex) of the cycle</span>
                    <span class="n">minn</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
                    <span class="n">cmin</span> <span class="o">=</span> <span class="n">cycle</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">minn</span><span class="p">)</span>

                    <span class="c"># now walk around the cycle starting from the smallest</span>
                    <span class="c"># point, and multiply around the cycle to obtain h</span>
                    <span class="c"># satisfying h[cmin] = cmin</span>
                    <span class="n">ap</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cmin</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">cmin</span><span class="p">):</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">nn</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index_neighbor</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">jg</span><span class="p">[</span> <span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="p">]</span>

                        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">perm_af_invert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="n">ap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">ap</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">perm_af_muln</span><span class="p">(</span><span class="o">*</span><span class="n">ap</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="n">cmin</span><span class="p">],</span> <span class="n">cycle</span><span class="p">[</span><span class="n">cmin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ig</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        insert edge (permutation g) moving i to ig (i &lt; ig)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jgs</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">jgslot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freejg</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># the last free generator place</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jg</span><span class="p">[</span><span class="n">jgslot</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span>
        <span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ig</span><span class="p">)</span>
        <span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">perm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jgslot</span><span class="p">)</span>
        <span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index_neighbor</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span>
        <span class="n">vertex</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">vertex</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span><span class="o">.</span><span class="n">perm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jgslot</span><span class="p">)</span>
        <span class="n">vertex</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span><span class="o">.</span><span class="n">index_neighbor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span>

    <span class="k">def</span> <span class="nf">jerrum_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">cri</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        filter the generators of the stabilizer subgroup G_alpha</span>

<span class="sd">        alpha point for which the stabilizer is computed</span>

<span class="sd">        cri[i] inverse of G._coset_repr[i] if `i` is not None</span>

<span class="sd">        Schreier lemma: the stabilizer subgroup G_alpha of G</span>
<span class="sd">        is generated by the schreier generators</span>
<span class="sd">        h = cosrep[ p2[i] ]**-1 * g[j] * cosrep[i]</span>
<span class="sd">        where j=0,..,len(gens)-1 and i=0,..,n-1, where n is the degree.</span>
<span class="sd">        Proof that h belongs to G_alpha:</span>
<span class="sd">        cosrep[k][alpha] = k for all k; cosrep[k]**-1[k] = alpha</span>
<span class="sd">        p1 = cosrep[i]; p2 = g[j]</span>
<span class="sd">        p3 = cosrep[ p2[i] ]; p3[alpha] = p2[i]</span>
<span class="sd">        p3**-1[p2[i] = alpha</span>
<span class="sd">        p3**-1[p2[p1[alpha]] = alpha, so h[alpha] = alpha</span>

<span class="sd">        Using Jerrum&#39;s filter one can reduce the len(gens)*n generators</span>
<span class="sd">        of G_alpha produced by the Schreier lemma to at most n-1</span>

<span class="sd">        Jerrum&#39;s filter:</span>
<span class="sd">        (see Cameron &#39;Permutation groups&#39;, page 22)</span>
<span class="sd">        _JGraph has n-1 vertices; the edges (i, j) are labelled by</span>
<span class="sd">        group elements `g` with j = imin(g) = min(i | g[i] != i);</span>
<span class="sd">        define m(graph) = sum(imin(g) for g in graph)</span>

<span class="sd">        At the beginning the graph has no edges, so it is</span>
<span class="sd">        an acyclic graph.</span>
<span class="sd">        Insert a group element `g` produced by the Schreier lemma;</span>
<span class="sd">        introduce in _JGraph an edge (imin(g), g[imin(g));</span>
<span class="sd">        if the graph contains a cycle,</span>
<span class="sd">        let `i0` be the smallest point in the cycle, and `h` the</span>
<span class="sd">        product of the group elements labelling the edges in the cycle,</span>
<span class="sd">        starting from `i0`; h[j] = j for j &lt;= i0;</span>
<span class="sd">        modify it eliminating the edge (i0, g0[i0])</span>
<span class="sd">        in the cycle; one obtains a new acyclic graph with</span>
<span class="sd">        m(graph_new) &gt; m(graph). `g0` can be expressed as a product</span>
<span class="sd">        of `h` and the other elements in the cycle.</span>
<span class="sd">        Then insert `h` in the graph, and so on.</span>
<span class="sd">        Since m &lt; n**2, this process ends after</span>
<span class="sd">        a finite number of times, so in the end one remains</span>
<span class="sd">        with an acyclic graph, with at most n-1 edges and</span>
<span class="sd">        the same number of generators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gens</span>
        <span class="n">cosrep</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">_coset_repr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jgs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jg</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freejg</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">perm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index_neighbor</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cosrep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">cosrep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">gens</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">p3</span> <span class="o">=</span> <span class="n">cri</span><span class="p">[</span> <span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="n">p3</span><span class="p">[</span><span class="n">p2</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">p1</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jg</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">gens</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jg</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">def</span> <span class="nf">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ig</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        remove edge from i to ig</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span>
        <span class="c"># remove the permutation labelling this edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jgs</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">jgslot</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span> <span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index_neighbor</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jg</span><span class="p">[</span><span class="n">jgslot</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freejg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jgslot</span><span class="p">)</span> <span class="c"># now we gained a free place</span>

        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">ig</span><span class="p">),</span> <span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">i</span><span class="p">)):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>
            <span class="n">j0</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">index_neighbor</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span>
            <span class="n">v</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">j0</span><span class="p">)</span>
            <span class="n">v</span><span class="o">.</span><span class="n">perm</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">j0</span><span class="p">)</span>
            <span class="c"># the index of the vertices &gt;= j0  in vertex[i] has changed</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)):</span>
                <span class="n">v</span><span class="o">.</span><span class="n">index_neighbor</span><span class="p">[</span> <span class="n">v</span><span class="o">.</span><span class="n">neighbor</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">v</span><span class="o">.</span><span class="n">index_neighbor</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">schreier_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">gen</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        traversal of the orbit of alpha</span>

<span class="sd">        Compute a traversal of the orbit of alpha, storing the values</span>
<span class="sd">        in G._coset_repr; G._coset_repr[i][alpha] = i if i belongs</span>
<span class="sd">        to the orbit of alpha.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span>
        <span class="n">G</span><span class="o">.</span><span class="n">_coset_repr</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="n">gen</span>
        <span class="n">G</span><span class="o">.</span><span class="n">_coset_repr_n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">genv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gens</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span>
        <span class="n">stg</span> <span class="o">=</span> <span class="p">[</span><span class="n">gen</span><span class="p">]</span>
        <span class="n">sta</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># backtrack when finished iterating over generators</span>
            <span class="k">if</span> <span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">h</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">sta</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">stg</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">continue</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">genv</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]]</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">sta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ag</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">_coset_repr</span><span class="p">[</span><span class="n">ag</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">gen1</span> <span class="o">=</span> <span class="n">perm_af_mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">stg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">G</span><span class="o">.</span><span class="n">_coset_repr</span><span class="p">[</span><span class="n">ag</span><span class="p">]</span> <span class="o">=</span> <span class="n">gen1</span>
                <span class="n">G</span><span class="o">.</span><span class="n">_coset_repr_n</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span>
                <span class="n">stg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gen1</span><span class="p">)</span>
                <span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span>

<div class="viewcode-block" id="PermutationGroup"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup">[docs]</a><span class="k">class</span> <span class="nc">PermutationGroup</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class defining a Permutation group.</span>

<span class="sd">    Permutation(generator_list) returns the permutation group</span>
<span class="sd">    generated by permutation_list.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">    &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">    &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">    &gt;&gt;&gt; G</span>
<span class="sd">    PermutationGroup([Permutation([0, 2, 1]), Permutation([1, 0, 2])])</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    [1] Holt, D., Eick, B., O&#39;Brien, E.</span>
<span class="sd">    &quot;Handbook of computational group theory&quot;</span>

<span class="sd">    [2] Seress, A.</span>
<span class="sd">    &quot;Permutation group algorithms&quot;</span>

<span class="sd">    [3] http://en.wikipedia.org/wiki/Schreier_vector</span>

<span class="sd">    [4] http://en.wikipedia.org/wiki/Nielsen_transformation</span>
<span class="sd">    #Product_replacement_algorithm</span>

<span class="sd">    [5] Frank Celler, Charles R.Leedham-Green, Scott H.Murray,</span>
<span class="sd">    Alice C.Niemeyer, and E.A.O&#39;Brien. &quot;Generating random</span>
<span class="sd">    elements of a finite group&quot;</span>

<span class="sd">    [6] http://en.wikipedia.org/wiki/Block_%28permutation_group_theory%29</span>

<span class="sd">    [7] http://www.algorithmist.com/index.php/Union_Find</span>

<span class="sd">    [8] http://en.wikipedia.org/wiki/Multiply_transitive_group#Multiply_transitive_groups</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        test if two groups have the same elements</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = [[1,2,0,3,4,5], [1,0,2,3,4,5], [2,1,0,3,4,5], [1,2,0,3,4,5]]</span>
<span class="sd">        &gt;&gt;&gt; a = [Permutation(p) for p in a]</span>
<span class="sd">        &gt;&gt;&gt; g = Permutation([1,2,3,4,5,0])</span>
<span class="sd">        &gt;&gt;&gt; G1,G2,G3 = [PermutationGroup(x) for x in [a[:2],a[2:4],[g,g**2]]]</span>
<span class="sd">        &gt;&gt;&gt; assert G1.order() == G2.order() == G3.order() == 6</span>
<span class="sd">        &gt;&gt;&gt; assert G1 == G2 and G1 != G3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">!=</span> <span class="n">gr</span><span class="o">.</span><span class="n">degree</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">!=</span> <span class="n">gr</span><span class="o">.</span><span class="n">order</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">gens1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">gr</span><span class="o">.</span><span class="n">has_element</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the direct product of two permutation groups as a permutation</span>
<span class="sd">        group.</span>

<span class="sd">        This implementation realizes the direct product by shifting</span>
<span class="sd">        the index set for the generators of the second group: so if we have</span>
<span class="sd">        G acting on n1 points and H acting on n2 points, G*H acts on n1+n2</span>
<span class="sd">        points.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import CyclicGroup</span>
<span class="sd">        &gt;&gt;&gt; G = CyclicGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; H = G*G</span>
<span class="sd">        &gt;&gt;&gt; H</span>
<span class="sd">        PermutationGroup([Permutation([1, 2, 3, 4, 0, 5, 6, 7, 8, 9]),</span>
<span class="sd">        Permutation([0, 1, 2, 3, 4, 6, 7, 8, 9, 5])])</span>
<span class="sd">        &gt;&gt;&gt; H.order()</span>
<span class="sd">        25</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gens1</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span><span class="o">.</span><span class="n">array_form</span> <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">gens2</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span><span class="o">.</span><span class="n">array_form</span> <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gens2</span><span class="p">)):</span>
            <span class="n">gens2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">n1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gens2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">gens2</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">gen</span> <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens2</span><span class="p">]</span>
        <span class="n">gens1</span> <span class="o">=</span> <span class="p">[</span><span class="n">gen</span> <span class="o">+</span> <span class="n">end</span> <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens1</span><span class="p">]</span>
        <span class="n">together</span> <span class="o">=</span> <span class="n">gens1</span> <span class="o">+</span> <span class="n">gens2</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">_new_from_array_form</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">together</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gr</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">gr</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The default constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_generators</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_abelian</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_transitive</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_sym</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_alt</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_primitive</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_transitivity_degree</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_max_div</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">array_form</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_generators</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">array_form</span><span class="p">)</span><span class="o">==</span><span class="n">size</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Permutation group size is not correct&quot;</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_degree</span> <span class="o">=</span> <span class="n">size</span>

        <span class="c"># these attributes are assigned after running schreier_sims</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_coset_repr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_coset_repr_n</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_stabilizers_gens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_strong_gens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_basic_orbits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_transversals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># these attributes are assigned after running _random_pr_init</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_random_gens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_random_pr_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">_random_prec_n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Initializes random generators for the product replacement algorithm.</span>

<span class="sd">        The implementation uses a modification of the original product</span>
<span class="sd">        replacement algorithm due to Leedham-Green, as described in [1],</span>
<span class="sd">        pp.69-71; also, see [2], pp.27-29 for a detailed theoretical</span>
<span class="sd">        analysis of the original product replacement algorithm, and [4].</span>

<span class="sd">        The product replacement algorithm is used for producing random,</span>
<span class="sd">        uniformly distributed elements of a group `G` with a set of generators</span>
<span class="sd">        `S`. For the initialization ``_random_pr_init``, a list `R` of</span>
<span class="sd">        `\max\{r, |S|\}` group generators is created as the attribute</span>
<span class="sd">        ``G._random_gens``, repeating elements of `S` if necessary, and the</span>
<span class="sd">        identity element of `G` is appended to `R` - we shall refer to this</span>
<span class="sd">        last element as the accumulator. Then the function ``random_pr()``</span>
<span class="sd">        is called ``n`` times, randomizing the list `R` while preserving</span>
<span class="sd">        the generation of `G` by `R`. The function ``random_pr()`` itself</span>
<span class="sd">        takes two random elements `g, h` among all elements of `R` but</span>
<span class="sd">        the accumulator and replaces `g` with a randomly chosen element</span>
<span class="sd">        from `\{gh, g(~h), hg, (~h)g\}`. Then the accumulator is multiplied</span>
<span class="sd">        by whatever `g` was replaced by. The new value of the accumulator is</span>
<span class="sd">        then returned by ``random_pr()``.</span>

<span class="sd">        The elements returned will eventually (for ``n`` large enough) become</span>
<span class="sd">        uniformly distributed across `G` ([5]). For practical purposes however,</span>
<span class="sd">        the values ``n = 50, r = 11`` are suggested in [1].</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        THIS FUNCTION HAS SIDE EFFECTS: it changes the attribute</span>
<span class="sd">        self._random_gens</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        random_pr</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">random_gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">[:]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">random_gens</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
                <span class="n">random_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random_gens</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">])</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">_new_from_array_form</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">deg</span><span class="p">))</span>
        <span class="n">random_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_gens</span> <span class="o">=</span> <span class="n">random_gens</span>

        <span class="c"># handle randomized input for testing purposes</span>
        <span class="k">if</span> <span class="n">_random_prec_n</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">(</span><span class="n">_random_prec</span> <span class="o">=</span> <span class="n">_random_prec_n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_union_find_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">ranks</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">not_rep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges two classes in a union-find data structure.</span>

<span class="sd">        Used in the implementation of Atkinson&#39;s algorithm as suggested in [1],</span>
<span class="sd">        pp.83-87. The class merging process uses union by rank as an</span>
<span class="sd">        optimization. ([7])</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives,</span>
<span class="sd">        ``parents``, the list of class sizes, ``ranks``, and the list of</span>
<span class="sd">        elements that are not representatives, ``not_rep``, are changed due to</span>
<span class="sd">        class merging.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minimal_block, _union_find_rep</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        [1] Holt, D., Eick, B., O&#39;Brien, E.</span>
<span class="sd">        &quot;Handbook of computational group theory&quot;</span>

<span class="sd">        [7] http://www.algorithmist.com/index.php/Union_Find</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rep_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_union_find_rep</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
        <span class="n">rep_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_union_find_rep</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rep_first</span> <span class="o">!=</span> <span class="n">rep_second</span><span class="p">:</span>
            <span class="c"># union by rank</span>
            <span class="k">if</span> <span class="n">ranks</span><span class="p">[</span><span class="n">rep_first</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ranks</span><span class="p">[</span><span class="n">rep_second</span><span class="p">]:</span>
                <span class="n">new_1</span><span class="p">,</span> <span class="n">new_2</span> <span class="o">=</span> <span class="n">rep_first</span><span class="p">,</span> <span class="n">rep_second</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_1</span><span class="p">,</span> <span class="n">new_2</span> <span class="o">=</span> <span class="n">rep_second</span><span class="p">,</span> <span class="n">rep_first</span>
            <span class="n">total_rank</span> <span class="o">=</span> <span class="n">ranks</span><span class="p">[</span><span class="n">new_1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ranks</span><span class="p">[</span><span class="n">new_2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">total_rank</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_div</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">parents</span><span class="p">[</span><span class="n">new_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_1</span>
            <span class="n">ranks</span><span class="p">[</span><span class="n">new_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rank</span>
            <span class="n">not_rep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_2</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_union_find_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">parents</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find representative of a class in a union-find data structure.</span>

<span class="sd">        Used in the implementation of Atkinson&#39;s algorithm as suggested in [1],</span>
<span class="sd">        pp.83-87. After the representative of the class to which ``num``</span>
<span class="sd">        belongs is found, path compression is performed as an optimization</span>
<span class="sd">        ([7]).</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives,</span>
<span class="sd">        ``parents``, is altered due to path compression.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minimal_block, _union_find_merge</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        [1] Holt, D., Eick, B., O&#39;Brien, E.</span>
<span class="sd">        &quot;Handbook of computational group theory&quot;</span>

<span class="sd">        [7] http://www.algorithmist.com/index.php/Union_Find</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rep</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">num</span><span class="p">,</span> <span class="n">parents</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">rep</span><span class="p">:</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">rep</span><span class="p">]</span>
        <span class="c"># path compression</span>
        <span class="n">temp</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">num</span><span class="p">,</span> <span class="n">parents</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">rep</span><span class="p">:</span>
            <span class="n">parents</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="n">rep</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rep</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.base"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.base">[docs]</a>    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a base from the Schreier-Sims algorithm.</span>

<span class="sd">        For a permutation group `G`, a base is a sequence of points</span>
<span class="sd">        `B = (b_1, b_2, ..., b_k)` such that no element of `G` apart from the</span>
<span class="sd">        identity fixes all the points in `B`. The concepts of a base and</span>
<span class="sd">        strong generating set and their applications are discussed in depth</span>
<span class="sd">        in [1],pp.87-89 and [2],pp.55-57.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; S.base</span>
<span class="sd">        [0, 1, 2]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        strong_gens, basic_transversals, basic_orbits, basic_stabilizers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>
</div>
<div class="viewcode-block" id="PermutationGroup.baseswap"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.baseswap">[docs]</a>    <span class="k">def</span> <span class="nf">baseswap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">randomized</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>\
                 <span class="n">transversals</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">basic_orbits</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">distr_gens</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Swap two consecutive base points in a base and strong generating set.</span>

<span class="sd">        If a base for a group `G` is given by `(b_1, b_2, ..., b_k)`, this</span>
<span class="sd">        function returns a base `(b_1, b_2, ..., b_{i+1}, b_i, ..., b_k)`,</span>
<span class="sd">        where `i` is given by ``pos``, and a strong generating set relative</span>
<span class="sd">        to that base. The original base and strong generating set are not</span>
<span class="sd">        modified.</span>
<span class="sd">        The randomized version (default) is of Las Vegas type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        ``base``, ``strong_gens`` - the base and strong generating set</span>
<span class="sd">        ``pos`` - position at which swapping is performed</span>
<span class="sd">        ``randomized`` - switch between randomized and deterministic version</span>
<span class="sd">        ``transversals`` - transversals for the basic orbits, if known</span>
<span class="sd">        ``basic_orbits`` - basic orbits, if known</span>
<span class="sd">        ``distr_gens`` - strong generators distributed by basic stabilizers,</span>
<span class="sd">        if known</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        ``(base, strong_gens)``, where ``base`` is the new base, and</span>
<span class="sd">        ``strong_gens`` is a generating set relative to it</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.util import _verify_bsgs</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; S.schreier_sims()</span>
<span class="sd">        &gt;&gt;&gt; S.baseswap(S.base, S.strong_gens, 1, randomized=False)</span>
<span class="sd">        ([0, 2, 1], [Permutation([1, 2, 3, 0]), Permutation([1, 0, 2, 3]), Permutation([0, 1, 3, 2]), Permutation([0, 3, 1, 2]), Permutation([0, 3, 2, 1])])</span>
<span class="sd">        &gt;&gt;&gt; S.base</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        &gt;&gt;&gt; _verify_bsgs(S, S.base, S.strong_gens)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        schreier_sims</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The deterministic version of the algorithm is discussed in</span>
<span class="sd">        [1],pp.102-103; the randomized version is discussed in [1],p.103, and</span>
<span class="sd">        [2],p.98. It is of Las Vegas type.</span>
<span class="sd">        Notice that [1] contains a mistake in the pseudocode and</span>
<span class="sd">        discussion of BASESWAP: on line 3 of the pseudocode,</span>
<span class="sd">        `|\beta_{i+1}^\left\langle T\right\rangle|` should be replaced by</span>
<span class="sd">        `|\beta_{i}^\left\langle T\right\rangle|`, and the same for the</span>
<span class="sd">        discussion of the algorithm.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># construct the basic orbits, generators for the stabilizer chain</span>
        <span class="c"># and transversal elements from whatever was provided</span>
        <span class="n">transversals</span><span class="p">,</span> <span class="n">basic_orbits</span><span class="p">,</span> <span class="n">distr_gens</span> <span class="o">=</span>\
        <span class="n">_handle_precomputed_bsgs</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">,</span> <span class="n">transversals</span><span class="p">,</span>\
                                 <span class="n">basic_orbits</span><span class="p">,</span> <span class="n">distr_gens</span><span class="p">)</span>
        <span class="n">base_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">stab_pos</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">distr_gens</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
        <span class="c"># size of orbit of base[pos] under the stabilizer we seek to insert</span>
        <span class="c"># in the stabilizer chain at position pos + 1</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basic_orbits</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">basic_orbits</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>\
               <span class="o">//</span><span class="nb">len</span><span class="p">(</span><span class="n">stab_pos</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="c"># initialize the wanted stabilizer by a subgroup</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">base_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">distr_gens</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][:]</span>
        <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">current_group</span> <span class="o">=</span> <span class="n">PermGroup</span><span class="p">([</span><span class="n">_new_from_array_form</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">))])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_group</span> <span class="o">=</span> <span class="n">PermGroup</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="c"># randomized version</span>
        <span class="k">if</span> <span class="n">randomized</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">schreier_vector</span> <span class="o">=</span> <span class="n">stab_pos</span><span class="o">.</span><span class="n">schreier_vector</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c"># add random elements of the stabilizer until they generate it</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_group</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">]))</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">stab_pos</span><span class="o">.</span><span class="n">random_stab</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>\
                                           <span class="n">schreier_vector</span><span class="o">=</span><span class="n">schreier_vector</span><span class="p">)</span>
                <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="n">current_group</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="c"># deterministic version</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Gamma</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">basic_orbits</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">Gamma</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">Gamma</span><span class="p">:</span>
                <span class="n">Gamma</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c"># add elements of the stabilizer until they generate it by</span>
            <span class="c"># ruling out member of the basic orbit of base[pos] along the way</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_group</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">]))</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">Gamma</span><span class="p">)</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">gamma</span><span class="p">]</span>
                <span class="n">x_inverse</span> <span class="o">=</span> <span class="o">~</span><span class="n">x</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">x_inverse</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">basic_orbits</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">Gamma</span> <span class="o">=</span> <span class="n">Gamma</span> <span class="o">-</span> <span class="n">current_group</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">temp</span><span class="p">]</span>
                    <span class="n">el</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>
                    <span class="k">if</span> <span class="n">el</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_group</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">]):</span>
                        <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                        <span class="n">current_group</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
                        <span class="n">Gamma</span> <span class="o">=</span> <span class="n">Gamma</span> <span class="o">-</span> <span class="n">current_group</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
        <span class="c"># build the new base and strong generating set</span>
        <span class="n">strong_gens_new_distr</span> <span class="o">=</span> <span class="n">distr_gens</span><span class="p">[:]</span>
        <span class="n">strong_gens_new_distr</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span>
        <span class="n">base_new</span> <span class="o">=</span> <span class="n">base</span><span class="p">[:]</span>
        <span class="n">base_new</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">base_new</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_new</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">base_new</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">strong_gens_new</span> <span class="o">=</span> <span class="n">_strong_gens_from_distr</span><span class="p">(</span><span class="n">strong_gens_new_distr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gen</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">strong_gens_new</span><span class="p">:</span>
                <span class="n">strong_gens_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base_new</span><span class="p">,</span> <span class="n">strong_gens_new</span></div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.basic_orbits"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits">[docs]</a>    <span class="k">def</span> <span class="nf">basic_orbits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the basic orbits relative to a base and strong generating set.</span>

<span class="sd">        If `(b_1, b_2, ..., b_k)` is a base for a group `G`, and</span>
<span class="sd">        `G^{(i)} = G_{b_1, b_2, ..., b_{i-1}}` is the `i`-th basic stabilizer</span>
<span class="sd">        (so that `G^{(1)} = G`), the `i`-th basic orbit relative to this base</span>
<span class="sd">        is the orbit of `b_i` under `G^{(i)}`. See [1],pp.87-89 for more</span>
<span class="sd">        information.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; S.basic_orbits</span>
<span class="sd">        [[0, 1, 2, 3], [1, 2, 3], [2, 3]]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        base, strong_gens, basic_transversals, basic_stabilizers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basic_orbits</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basic_orbits</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.basic_stabilizers"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers">[docs]</a>    <span class="k">def</span> <span class="nf">basic_stabilizers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a chain of stabilizers relative to a base and strong generating</span>
<span class="sd">        set.</span>

<span class="sd">        The `i`-th basic stabilizer `G^{(i)}` relative to a base</span>
<span class="sd">        `(b_1, b_2, ..., b_k)` is `G_{b_1, b_2, ..., b_{i-1}}`. For more</span>
<span class="sd">        information, see [1],pp.87-89.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup</span>
<span class="sd">        &gt;&gt;&gt; A = AlternatingGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; A.schreier_sims()</span>
<span class="sd">        &gt;&gt;&gt; A.base</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; A.basic_stabilizers</span>
<span class="sd">        [PermutationGroup([Permutation([1, 2, 0, 3]), Permutation([0, 2, 3, 1]), Permutation([0, 3, 1, 2])]), PermutationGroup([Permutation([0, 2, 3, 1]), Permutation([0, 3, 1, 2])])]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        base, strong_gens, basic_orbits, basic_transversals</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="n">strong_gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strong_gens</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>
        <span class="n">distr_gens</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">)</span>
        <span class="n">basic_stabilizers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">gens</span> <span class="ow">in</span> <span class="n">distr_gens</span><span class="p">:</span>
            <span class="n">basic_stabilizers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PermutationGroup</span><span class="p">(</span><span class="n">gens</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">basic_stabilizers</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.basic_transversals"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals">[docs]</a>    <span class="k">def</span> <span class="nf">basic_transversals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return basic transversals relative to a base and strong generating set.</span>

<span class="sd">        The basic transversals are transversals of the basic orbits. They</span>
<span class="sd">        are provided as a list of dictionaries, each dictionary having</span>
<span class="sd">        keys - the elements of one of the basic orbits, and values - the</span>
<span class="sd">        corresponding transversal elements. See [1],pp.87-89 for more</span>
<span class="sd">        information.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup</span>
<span class="sd">        &gt;&gt;&gt; A = AlternatingGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; A.basic_transversals</span>
<span class="sd">        [{0: Permutation([0, 1, 2, 3]), 1: Permutation([1, 2, 0, 3]),\</span>
<span class="sd">        2: Permutation([2, 0, 1, 3]), 3: Permutation([3, 0, 2, 1])},\</span>
<span class="sd">        {1: Permutation([0, 1, 2, 3]), 2: Permutation([0, 2, 3, 1]),\</span>
<span class="sd">        3: Permutation([0, 3, 1, 2])}]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        strong_gens, base, basic_orbits, basic_stabilizers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span>
</div>
<div class="viewcode-block" id="PermutationGroup.commutator"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.commutator">[docs]</a>    <span class="k">def</span> <span class="nf">commutator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        commutator subgroup</span>

<span class="sd">        The commutator subgroup is the subgroup generated by all</span>
<span class="sd">        commutators; it is equal to the normal closure of the set</span>
<span class="sd">        of commutators of the generators.</span>

<span class="sd">        see http://groupprops.subwiki.org/wiki/Derived_subgroup</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1, 0, 2, 4, 3])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0, 1, 3, 2, 4])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; C = G.commutator()</span>
<span class="sd">        &gt;&gt;&gt; list(C.generate(af=True))</span>
<span class="sd">        [[0, 1, 2, 3, 4], [0, 1, 3, 4, 2], [0, 1, 4, 2, 3]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">gens_inv</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm_af_invert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">]</span>
        <span class="n">set_commutators</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">p1inv</span> <span class="o">=</span> <span class="n">gens_inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">gens</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">p2inv</span> <span class="o">=</span> <span class="n">gens_inv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">p1</span><span class="p">[</span><span class="n">p2</span><span class="p">[</span><span class="n">p1inv</span><span class="p">[</span><span class="n">k</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">p2inv</span><span class="p">]</span>
                <span class="n">ct</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">set_commutators</span><span class="p">:</span>
                    <span class="n">set_commutators</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
        <span class="n">cms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Permutation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">set_commutators</span><span class="p">]</span>
        <span class="n">G2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_closure</span><span class="p">(</span><span class="n">cms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">G2</span>
</div>
<div class="viewcode-block" id="PermutationGroup.coset_decomposition"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.coset_decomposition">[docs]</a>    <span class="k">def</span> <span class="nf">coset_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decompose `g` as h_0*...*h_{len(u)}</span>

<span class="sd">        The Schreier-Sims coset representation u of `G`</span>
<span class="sd">        gives a univoque decomposition of an element `g`</span>
<span class="sd">        as h_0*...*h_{len(u)}, where h_i belongs to u[i]</span>

<span class="sd">        Output: [h_0, .., h_{len(u)}] if `g` belongs to `G`</span>
<span class="sd">                False otherwise</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([[0, 1, 3, 7, 6, 4], [2, 5]])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([[0, 1, 3, 2], [4, 5, 7, 6]])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; c = Permutation([[0, 1, 2, 3, 4], [5, 6, 7]])</span>
<span class="sd">        &gt;&gt;&gt; G.coset_decomposition(c)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; c = Permutation([[0, 6], [1, 7], [2, 4], [3, 5]])</span>
<span class="sd">        &gt;&gt;&gt; G.coset_decomposition(c)</span>
<span class="sd">        [[6, 4, 2, 0, 7, 5, 3, 1], [0, 4, 1, 5, 2, 6, 3, 7], [0, 1, 2, 3, 4, 5, 6, 7]]</span>
<span class="sd">        &gt;&gt;&gt; G.has_element(c)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_repr</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Permutation</span><span class="p">):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">g1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">perm_af_invert</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                    <span class="n">g1</span> <span class="o">=</span> <span class="n">perm_af_mul</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">g1</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">perm_af_muln</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="PermutationGroup.coset_rank"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.coset_rank">[docs]</a>    <span class="k">def</span> <span class="nf">coset_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        rank using Schreier-Sims representation</span>

<span class="sd">        The coset rank of `g` is the ordering number in which</span>
<span class="sd">        it appears in the lexicographic listing according to the</span>
<span class="sd">        coset decomposition, see coset_decomposition;</span>
<span class="sd">        the ordering is the same as in G.generate(method=&#39;coset&#39;).</span>
<span class="sd">        If `g` does not belong to the group it returns None</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([[0, 1, 3, 7, 6, 4], [2, 5]])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([[0, 1, 3, 2], [4, 5, 7, 6]])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; c = Permutation([[0, 1, 2, 3, 4], [5, 6, 7]])</span>
<span class="sd">        &gt;&gt;&gt; G.coset_rank(c)</span>
<span class="sd">        &gt;&gt;&gt; c = Permutation([[0, 6], [1, 7], [2, 4], [3, 5]])</span>
<span class="sd">        &gt;&gt;&gt; G.coset_rank(c)</span>
<span class="sd">        40</span>
<span class="sd">        &gt;&gt;&gt; G.coset_unrank(40, af=True)</span>
<span class="sd">        [6, 7, 4, 5, 2, 3, 0, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_repr</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Permutation</span><span class="p">):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">un</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr_n</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">un</span><span class="p">[</span><span class="n">m</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
        <span class="n">base</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="n">a1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span><span class="p">:</span>
            <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">g1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                    <span class="n">a1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">rank</span> <span class="o">+=</span> <span class="n">j</span><span class="o">*</span><span class="n">base</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">perm_af_invert</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                    <span class="n">g1</span> <span class="o">=</span> <span class="n">perm_af_mul</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">g1</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">perm_af_muln</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rank</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="PermutationGroup.coset_repr"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.coset_repr">[docs]</a>    <span class="k">def</span> <span class="nf">coset_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Schreier-Sims representation of the group.</span>

<span class="sd">        The Schreier-Sims representation is the list of the cosets of</span>
<span class="sd">        the chain of stabilizers, see schreier_sims.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.coset_repr()</span>
<span class="sd">        [[[0, 1, 2], [1, 0, 2], [2, 0, 1]], [[0, 1, 2], [0, 2, 1]]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span>
</div>
<div class="viewcode-block" id="PermutationGroup.coset_unrank"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.coset_unrank">[docs]</a>    <span class="k">def</span> <span class="nf">coset_unrank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        unrank using Schreier-Sims representation</span>

<span class="sd">        coset_unrank is the inverse operation of coset_rank</span>
<span class="sd">        if 0 &lt;= rank &lt; order; otherwise it returns None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_repr</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rank</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">un</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr_n</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nb</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">un</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rank</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">un</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">perm_af_muln</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">h</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_new_from_array_form</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.degree"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.degree">[docs]</a>    <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the size of the permutations in the group.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1,0])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a])</span>
<span class="sd">        &gt;&gt;&gt; G.degree</span>
<span class="sd">        2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degree</span>
</div>
<div class="viewcode-block" id="PermutationGroup.generate"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;coset&quot;</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return iterator to generate the elements of the group</span>

<span class="sd">        Iteration is done with one of these methods:</span>
<span class="sd">          method=&#39;coset&#39;  using the Schreier-Sims coset representation</span>
<span class="sd">          method=&#39;dimino&#39; using the Dimino method</span>

<span class="sd">        If af = True it yields the array form of the permutations</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0, 2, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; g = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; list(g.generate(af=True))</span>
<span class="sd">        [[0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 3, 1], [0, 2, 1, 3], [0, 3, 2, 1], [0, 3, 1, 2]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;coset&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_schreier_sims</span><span class="p">(</span><span class="n">af</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;dimino&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_dimino</span><span class="p">(</span><span class="n">af</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;there is not this method&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.generate_dimino"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.generate_dimino">[docs]</a>    <span class="k">def</span> <span class="nf">generate_dimino</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        yield group elements using Dimino&#39;s algorithm</span>

<span class="sd">        If af == True it yields the array form of the permutations</span>

<span class="sd">        Reference:</span>
<span class="sd">        [1] The implementation of various algorithms for Permutation Groups in</span>
<span class="sd">        the Computer Algebra System: AXIOM, N.J. Doye, M.Sc. Thesis</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0, 2, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; g = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; list(g.generate_dimino(af=True))</span>
<span class="sd">        [[0, 1, 2, 3], [0, 2, 1, 3], [0, 2, 3, 1], [0, 1, 3, 2], [0, 3, 2, 1], [0, 3, 1, 2]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idn</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">element_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">idn</span><span class="p">]</span>
        <span class="n">set_element_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idn</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">idn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">_new_from_array_form</span><span class="p">(</span><span class="n">idn</span><span class="p">)</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)):</span>
            <span class="c"># D elements of the subgroup G_i generated by gens[:i]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">element_list</span><span class="p">[:]</span>
            <span class="n">N</span> <span class="o">=</span> <span class="p">[</span><span class="n">idn</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">N</span>
                <span class="n">N</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">ag</span> <span class="o">=</span> <span class="n">perm_af_mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set_element_list</span><span class="p">:</span>
                            <span class="c"># produce G_i*g</span>
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                                <span class="n">order</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="n">ap</span> <span class="o">=</span> <span class="n">perm_af_mul</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
                                    <span class="k">yield</span> <span class="n">ap</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">p</span> <span class="o">=</span> <span class="n">_new_from_array_form</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>
                                    <span class="k">yield</span> <span class="n">p</span>
                                <span class="n">element_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>
                                <span class="n">set_element_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
                                <span class="n">N</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">element_list</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.generate_schreier_sims"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.generate_schreier_sims">[docs]</a>    <span class="k">def</span> <span class="nf">generate_schreier_sims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        yield group elements using the Schreier-Sims representation</span>

<span class="sd">        If af = True it yields the array form of the permutations</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0, 2, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; g = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; list(g.generate_schreier_sims(af=True))</span>
<span class="sd">        [[0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 3, 1], [0, 2, 1, 3], [0, 3, 2, 1], [0, 3, 1, 2]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get1</span><span class="p">(</span><span class="n">posmax</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">posmax</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">posmax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_repr</span><span class="p">()</span>
        <span class="c"># stg stack of group elements</span>
        <span class="n">stg</span> <span class="o">=</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="c"># posmax[i] = len(u[i])</span>
        <span class="n">posmax</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">u</span><span class="p">]</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">get1</span><span class="p">(</span><span class="n">posmax</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n1</span>
        <span class="n">posmax</span> <span class="o">=</span> <span class="n">posmax</span><span class="p">[:</span><span class="n">n1</span><span class="p">]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># backtrack when finished iterating over coset</span>
            <span class="k">if</span> <span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">posmax</span><span class="p">[</span><span class="n">h</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">StopIteration</span>
                <span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">h</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">stg</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">continue</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">perm_af_mul</span><span class="p">(</span><span class="n">stg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]])</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">stg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">h</span> <span class="o">==</span> <span class="n">n1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">p</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">_new_from_array_form</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">p1</span>
                <span class="n">stg</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">h</span> <span class="o">-=</span> <span class="mi">1</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.generators"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.generators">[docs]</a>    <span class="k">def</span> <span class="nf">generators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the generators of the group in array form.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.generators</span>
<span class="sd">        [Permutation([0, 2, 1]), Permutation([1, 0, 2])]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generators</span>
</div>
<div class="viewcode-block" id="PermutationGroup.has_element"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.has_element">[docs]</a>    <span class="k">def</span> <span class="nf">has_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        test if `g` belongs to G; see coset_decomposition</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0, 2, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; g = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; g.has_element(Permutation([0, 1, 3, 2]))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g.has_element(Permutation([1, 2, 3, 0]))</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coset_decomposition</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">array_form</span><span class="p">))</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.is_abelian"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_abelian">[docs]</a>    <span class="k">def</span> <span class="nf">is_abelian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the group is Abelian.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.is_abelian</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a])</span>
<span class="sd">        &gt;&gt;&gt; G.is_abelian</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_abelian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_abelian</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_abelian</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">perm_af_commutes_with</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_abelian</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_alt_sym"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym">[docs]</a>    <span class="k">def</span> <span class="nf">is_alt_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">_random_prec</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Monte Carlo test for the symmetric/alternating group for degrees &gt;= 8.</span>

<span class="sd">        More specifically, it is one-sided Monte Carlo with the</span>
<span class="sd">        answer True (i.e., G is symmetric/alternating) guaranteed to be correct,</span>
<span class="sd">        and the answer False being incorrect with probability eps.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The algorithm itself uses some nontrivial results from group theory and</span>
<span class="sd">        number theory:</span>
<span class="sd">        1) If a transitive group `G` of degree ``n`` contains an element</span>
<span class="sd">        with a cycle of length `n/2 &lt; p &lt; n-2` for `p` a prime, `G` is the</span>
<span class="sd">        symmetric or alternating group ([1], pp.81-82)</span>
<span class="sd">        2) The proportion of elements in the symmetric/alternating group having</span>
<span class="sd">        the property described in 1) is approximately `\log(2)/\log(n)`</span>
<span class="sd">        ([1], p.82; [2], pp.226-227).</span>
<span class="sd">        The helper function ``_check_cycles_alt_sym`` is used to</span>
<span class="sd">        go over the cycles in a permutation and look for ones satisfying 1).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; D = DihedralGroup(10)</span>
<span class="sd">        &gt;&gt;&gt; D.is_alt_sym()</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        _check_cycles_alt_sym</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_random_prec</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_transitive</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">17</span><span class="p">:</span>
                <span class="n">c_n</span> <span class="o">=</span> <span class="mf">0.34</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_n</span> <span class="o">=</span> <span class="mf">0.57</span>
            <span class="n">d_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_n</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">N_eps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span><span class="o">/</span><span class="n">d_n</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_eps</span><span class="p">):</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">_check_cycles_alt_sym</span><span class="p">(</span><span class="n">perm</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;N_eps&#39;</span><span class="p">]):</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">_check_cycles_alt_sym</span><span class="p">(</span><span class="n">perm</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_normal"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_normal">[docs]</a>    <span class="k">def</span> <span class="nf">is_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        test if G=self is a normal subgroup of gr</span>

<span class="sd">        G is normal in gr if</span>
<span class="sd">        for each g2 in G, g1 in gr, g = g1*g2*g1**-1 belongs to G</span>
<span class="sd">        It is sufficient to check this for each g1 in gr.generator and</span>
<span class="sd">        g2 g2 in G.generator</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1, 2, 0])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G1 = PermutationGroup([a, Permutation([2, 0, 1])])</span>
<span class="sd">        &gt;&gt;&gt; G1.is_normal(G)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gens2</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">gens1</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">gr</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">g1</span> <span class="ow">in</span> <span class="n">gens1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">g2</span> <span class="ow">in</span> <span class="n">gens2</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">perm_af_muln</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">perm_af_invert</span><span class="p">(</span><span class="n">g1</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_decomposition</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_primitive"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_primitive">[docs]</a>    <span class="k">def</span> <span class="nf">is_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">randomized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test a group for primitivity.</span>

<span class="sd">        A permutation group `G` acting on a set `S` is called primitive if</span>
<span class="sd">        `S` contains no nontrivial block under the action of `G`</span>
<span class="sd">        (a block is nontrivial if its cardinality is more than `1`).</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The algorithm is described in [1], p.83, and uses the function</span>
<span class="sd">        minimal_block to search for blocks of the form `\{0, k\}` for `k`</span>
<span class="sd">        ranging over representatives for the orbits of `G_0`, the stabilizer of</span>
<span class="sd">        `0`. This algorithm has complexity `O(n^2)` where `n` is the degree</span>
<span class="sd">        of the group, and will perform badly if `G_0` is small.</span>

<span class="sd">        There are two implementations offered: one finds `G_0`</span>
<span class="sd">        deterministically using the function ``stabilizer``, and the other</span>
<span class="sd">        (default) produces random elements of `G_0` using ``random_stab``,</span>
<span class="sd">        hoping that they generate a subgroup of `G_0` with not too many more</span>
<span class="sd">        orbits than G_0 (this is suggested in [1], p.83). Behavior is changed</span>
<span class="sd">        by the ``randomized`` flag.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; D = DihedralGroup(10)</span>
<span class="sd">        &gt;&gt;&gt; D.is_primitive()</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minimal_block, random_stab</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_primitive</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_primitive</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="k">if</span> <span class="n">randomized</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">)</span>
            <span class="n">random_stab_gens</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schreier_vector</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="n">random_stab_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_stab</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">stab</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">random_stab_gens</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stabilizer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">orbits</span> <span class="o">=</span> <span class="n">stab</span><span class="o">.</span><span class="n">orbits</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbits</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal_block</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_primitive</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_primitive</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_solvable"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_solvable">[docs]</a>    <span class="k">def</span> <span class="nf">is_solvable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        test if the group G is solvable</span>

<span class="sd">        G is solvable if the derived series</span>
<span class="sd">        G = G_0 &lt; G_1 &lt; ... &lt; G_k = 1, with G_{i+1} = G.commutator()</span>
<span class="sd">        see http://en.wikipedia.org/wiki/Solvable_group</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1,2,0])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1,0,2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.is_solvable()</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">commutator</span><span class="p">()</span>
            <span class="n">order1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">order1</span> <span class="o">==</span> <span class="n">order</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order1</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_subgroup"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_subgroup">[docs]</a>    <span class="k">def</span> <span class="nf">is_subgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        test if self is a subgroup of gr</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1,2,3,4,0])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1,0,2,3,4])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; c = Permutation([1,0,3,2,4])</span>
<span class="sd">        &gt;&gt;&gt; G1 = PermutationGroup([a, c])</span>
<span class="sd">        &gt;&gt;&gt; G1.is_subgroup(G)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">!=</span> <span class="n">gr</span><span class="o">.</span><span class="n">degree</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">gr</span><span class="o">.</span><span class="n">order</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">gens1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">gr</span><span class="o">.</span><span class="n">has_element</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.is_transitive"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_transitive">[docs]</a>    <span class="k">def</span> <span class="nf">is_transitive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        test if the group is transitive</span>

<span class="sd">        A group is transitive if it has a single orbit.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([2, 0, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; G1 = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G1.is_transitive</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; c = Permutation([2, 3, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; G2 = PermutationGroup([a, c])</span>
<span class="sd">        &gt;&gt;&gt; G2.is_transitive</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transitive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transitive</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_transitive</span> <span class="o">=</span> <span class="n">ans</span>
        <span class="k">return</span> <span class="n">ans</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.max_div"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.max_div">[docs]</a>    <span class="k">def</span> <span class="nf">max_div</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maximum proper divisor of the degree of a permutation group.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        Obviously, this is the degree divided by its minimal proper divisor</span>
<span class="sd">        (larger than `1`, if one exists). As it is guaranteed to be prime,</span>
<span class="sd">        the ``sieve`` from ``sympy.ntheory`` is used.</span>
<span class="sd">        This function is also used as an optimization tool for the functions</span>
<span class="sd">        ``minimal_block`` and ``_union_find_merge``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([Permutation([0,2,1,3])])</span>
<span class="sd">        &gt;&gt;&gt; G.max_div</span>
<span class="sd">        2</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minimal_block, _union_find_merge</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_div</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_div</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sieve</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="n">x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_div</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="PermutationGroup.minimal_block"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.minimal_block">[docs]</a>    <span class="k">def</span> <span class="nf">minimal_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        For a transitive group, finds the block system generated by ``points``.</span>

<span class="sd">        If a group `G` acts on a set `S`, a nonempty subset `B` of `S` is</span>
<span class="sd">        called a block under the action of `G` if for all `g` in `G` we have</span>
<span class="sd">        `gB = B` (`g` fixes `B`) or `gB` and `B` have no common points</span>
<span class="sd">        (`g` moves `B` entirely). ([1], p.23; [6]).</span>
<span class="sd">        The distinct translates `gB` of a block `B` for `g` in `G` partition</span>
<span class="sd">        the set `S` and this set of translates is known as a block system.</span>
<span class="sd">        Moreover, we obviously have that all blocks in the partition have</span>
<span class="sd">        the same size, hence the block size divides `|S|` ([1], p.23).</span>
<span class="sd">        A `G`-congruence is an equivalence relation `~` on the set `S` such that</span>
<span class="sd">        `a ~ b` implies `g(a) ~ g(b)` for all `g` in `G`. For a</span>
<span class="sd">        transitive group, the equivalence classes of a `G`-congruence and the</span>
<span class="sd">        blocks of a block system are the same thing ([1], p.23).</span>
<span class="sd">        The algorithm below checks the group for transitivity, and then finds</span>
<span class="sd">        the `G`-congruence generated by the pairs `(p_0, p_1), (p_0, p_2), ...,</span>
<span class="sd">        (p_0,p_{k-1})` which is the same as finding the maximal block system</span>
<span class="sd">        (i.e., the one with minimum block size) such that</span>
<span class="sd">        `p_0, ..., p_{k-1}` are in the same block ([1], p.83).</span>
<span class="sd">        It is an implementation of Atkinson&#39;s algorithm, as suggested in [1],</span>
<span class="sd">        and manipulates an equivalence relation on the set `S` using a</span>
<span class="sd">        union-find data structure. The running time is just above</span>
<span class="sd">        `O(|points||S|)`. ([1], pp.83-87; [7]).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; D = DihedralGroup(10)</span>
<span class="sd">        &gt;&gt;&gt; D.minimal_block([0,5])</span>
<span class="sd">        [0, 6, 2, 8, 4, 0, 6, 2, 8, 4]</span>
<span class="sd">        &gt;&gt;&gt; D.minimal_block([0,1])</span>
<span class="sd">        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        _union_find_rep, _union_find_merge, is_transitive, is_primitive</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_transitive</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="c"># initialize the list of equivalence class representatives</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">not_rep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="c"># the block size must divide the degree of the group</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_div</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">parents</span><span class="p">[</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">not_rep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ranks</span><span class="p">[</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">len_not_rep</span> <span class="o">=</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len_not_rep</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">not_rep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                <span class="c"># find has side effects: performs path compression on the list</span>
                <span class="c"># of representatives</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_union_find_rep</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
                <span class="c"># union has side effects: performs union by rank on the list</span>
                <span class="c"># of representatives</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_union_find_merge</span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="n">gen</span><span class="p">(</span><span class="n">delta</span><span class="p">),</span> <span class="n">ranks</span><span class="p">,</span>\
                                                 <span class="n">parents</span><span class="p">,</span> <span class="n">not_rep</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">temp</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
                <span class="n">len_not_rep</span> <span class="o">+=</span> <span class="n">temp</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c"># force path compression to get the final state of the equivalence</span>
            <span class="c"># relation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_union_find_rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parents</span>
</div>
<div class="viewcode-block" id="PermutationGroup.normal_closure"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.normal_closure">[docs]</a>    <span class="k">def</span> <span class="nf">normal_closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        normal closure in self of a list gens2 of permutations</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1, 2, 0])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.order()</span>
<span class="sd">        6</span>
<span class="sd">        &gt;&gt;&gt; G1 = G.normal_closure([a])</span>
<span class="sd">        &gt;&gt;&gt; list(G1.generate(af=True))</span>
<span class="sd">        [[0, 1, 2], [1, 2, 0], [2, 0, 1]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G2</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">G2</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">G2</span>
        <span class="n">gens1</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">gens2</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">G2</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">g1</span> <span class="ow">in</span> <span class="n">gens1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">for</span> <span class="n">g2</span> <span class="ow">in</span> <span class="n">gens2</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">perm_af_muln</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">perm_af_invert</span><span class="p">(</span><span class="n">g1</span><span class="p">))</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">G2</span><span class="o">.</span><span class="n">has_element</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                        <span class="n">gens2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">generators</span> <span class="o">+</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
                        <span class="n">G2</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">gens2</span><span class="p">)</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">G2</span>
</div>
<div class="viewcode-block" id="PermutationGroup.orbit"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.orbit">[docs]</a>    <span class="k">def</span> <span class="nf">orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;tuples&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Compute the orbit of alpha `\{g(\alpha) | g \in G\}` as a set.</span>

<span class="sd">        The time complexity of the algorithm used here is `O(|Orb|*r)` where</span>
<span class="sd">        `|Orb|` is the size of the orbit and `r` is the number of generators of</span>
<span class="sd">        the group. For a more detailed analysis, see [1], p.78, [2], pp.19-21.</span>
<span class="sd">        Here alpha can be a single point, or a list of points.</span>

<span class="sd">        If alpha is a single point, the ordinary orbit is computed.</span>
<span class="sd">        if alpha is a list of points, there are three available options:</span>

<span class="sd">        &#39;union&#39; - computes the union of the orbits of the points in the list</span>
<span class="sd">        &#39;tuples&#39; - computes the orbit of the list interpreted as an ordered</span>
<span class="sd">        tuple under the group action ( i.e., g((1,2,3)) = (g(1), g(2), g(3)) )</span>
<span class="sd">        &#39;sets&#39; - computes the orbit of the list interpreted as a sets</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1,2,0,4,5,6,3])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a])</span>
<span class="sd">        &gt;&gt;&gt; G.orbit(0)</span>
<span class="sd">        set([0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; G.orbit([0,4], &#39;union&#39;)</span>
<span class="sd">        set([0, 1, 2, 3, 4, 5, 6])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        orbit_transversal</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="s">&#39;__getitem__&#39;</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&#39;union&#39;</span><span class="p">:</span>
            <span class="n">orb</span> <span class="o">=</span> <span class="n">alpha</span>
            <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">:</span>
                <span class="n">used</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">gen</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                        <span class="n">orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                        <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&#39;tuples&#39;</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">orb</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
            <span class="n">used</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">alpha</span><span class="p">])</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">gen</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used</span><span class="p">:</span>
                        <span class="n">orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                        <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&#39;sets&#39;</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">orb</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
            <span class="n">used</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">alpha</span><span class="p">])</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">gen</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used</span><span class="p">:</span>
                        <span class="n">orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                        <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="PermutationGroup.orbit_rep"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.orbit_rep">[docs]</a>    <span class="k">def</span> <span class="nf">orbit_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">schreier_vector</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a group element which sends ``alpha`` to ``beta``.</span>

<span class="sd">        If ``beta`` is not in the orbit of ``alpha``, the function returns</span>
<span class="sd">        ``False``. This implementation makes use of the schreier vector.</span>
<span class="sd">        For a proof of correctness, see [1], p.80</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup</span>
<span class="sd">        &gt;&gt;&gt; G = AlternatingGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; G.orbit_rep(0,4)</span>
<span class="sd">        Permutation([4, 2, 3, 0, 1])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        schreier_vector</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">schreier_vector</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">schreier_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schreier_vector</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">schreier_vector</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">_new_from_array_form</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">schreier_vector</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">gens</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">gens</span><span class="p">[</span><span class="n">k</span><span class="p">])(</span><span class="n">beta</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">schreier_vector</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">u</span>
</div>
<div class="viewcode-block" id="PermutationGroup.orbit_transversal"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.orbit_transversal">[docs]</a>    <span class="k">def</span> <span class="nf">orbit_transversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">pairs</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Computes a transversal for the orbit of ``alpha`` as a set.</span>

<span class="sd">        For a permutation group `G`, a transversal for the orbit</span>
<span class="sd">        `Orb = \{g(\alpha) | g \in G\}` is a set</span>
<span class="sd">        `\{g_\beta | g_\beta(\alpha) = \beta\}` for `\beta \in Orb`.</span>
<span class="sd">        Note that there may be more than one possible transversal.</span>
<span class="sd">        If ``pairs`` is set to ``True``, it returns the list of pairs</span>
<span class="sd">        `(\beta, g_\beta)`. For a proof of correctness, see [1], p.79</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; G = DihedralGroup(6)</span>
<span class="sd">        &gt;&gt;&gt; G.orbit_transversal(0)</span>
<span class="sd">        [Permutation([0, 1, 2, 3, 4, 5]), Permutation([1, 2, 3, 4, 5, 0]),</span>
<span class="sd">        Permutation([5, 4, 3, 2, 1, 0]), Permutation([2, 3, 4, 5, 0, 1]),</span>
<span class="sd">        Permutation([4, 3, 2, 1, 0, 5]), Permutation([3, 4, 5, 0, 1, 2])]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        orbit</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="p">[(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">_new_from_array_form</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)))]</span>
        <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">used</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">gen</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">temp</span><span class="p">,</span> <span class="n">gen</span><span class="o">*</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tr</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="PermutationGroup.orbits"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.orbits">[docs]</a>    <span class="k">def</span> <span class="nf">orbits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rep</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        compute the orbits of G;</span>
<span class="sd">        if rep=False it returns a list of sets</span>
<span class="sd">        else it returns a list of representatives of the orbits</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.orbits()</span>
<span class="sd">        [set([0, 1, 2])]</span>
<span class="sd">        &gt;&gt;&gt; G.orbits(rep=True)</span>
<span class="sd">        [0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degree</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">s1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">si</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rep</span><span class="p">:</span>
                <span class="n">orbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">orbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
            <span class="n">s1</span> <span class="o">-=</span> <span class="n">si</span>
        <span class="k">return</span> <span class="n">orbs</span>
</div>
<div class="viewcode-block" id="PermutationGroup.order"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.order">[docs]</a>    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return the order of the group</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.order()</span>
<span class="sd">        6</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sym</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_alt</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr_n</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">m</span>
</div>
<div class="viewcode-block" id="PermutationGroup.random"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.random">[docs]</a>    <span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return a random group element</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_unrank</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">af</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.random_pr"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.random_pr">[docs]</a>    <span class="k">def</span> <span class="nf">random_pr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gen_count</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">_random_prec</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random group element using product replacement.</span>

<span class="sd">        For the details of the product replacement algorithm, see</span>
<span class="sd">        ``_random_pr_init`` In ``random_pr`` the actual &#39;product replacement&#39;</span>
<span class="sd">        is performed. Notice that if the attribute ``_random_gens``</span>
<span class="sd">        is empty, it needs to be initialized by ``_random_pr_init``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        _random_pr_init</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_gens</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_random_pr_init</span><span class="p">(</span><span class="n">gen_count</span><span class="p">,</span> <span class="n">iterations</span><span class="p">)</span>
        <span class="n">random_gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_gens</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">random_gens</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c"># handle randomized input for testing purposes</span>
        <span class="k">if</span> <span class="n">_random_prec</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">random_gens</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>
            <span class="n">random_gens</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_gens</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">random_gens</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">**</span><span class="n">e</span><span class="p">)</span><span class="o">*</span><span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">random_gens</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="n">random_gens</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">random_gens</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="PermutationGroup.random_stab"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.random_stab">[docs]</a>    <span class="k">def</span> <span class="nf">random_stab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">schreier_vector</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">_random_prec</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Random element from the stabilizer of ``alpha``.</span>

<span class="sd">        The schreier vector for ``alpha`` is an optional argument used</span>
<span class="sd">        for speeding up repeated calls. The algorithm is described in [1], p.81</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        random_pr, orbit_rep</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">schreier_vector</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">schreier_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schreier_vector</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_random_prec</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">rand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rand</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;rand&#39;</span><span class="p">]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbit_rep</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">schreier_vector</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">rand</span>
</div>
<div class="viewcode-block" id="PermutationGroup.schreier_sims"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims">[docs]</a>    <span class="k">def</span> <span class="nf">schreier_sims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Schreier-Sims algorithm.</span>

<span class="sd">        It computes the generators of the stabilizers chain</span>
<span class="sd">        G &gt; G_{b_1} &gt; .. &gt; G_{b1,..,b_r} &gt; 1</span>
<span class="sd">        in which G_{b_1,..,b_i} stabilizes b_1,..,b_i,</span>
<span class="sd">        and the corresponding `s` cosets.</span>
<span class="sd">        An element of the group can be written univoquely</span>
<span class="sd">        as the product h_1*..*h_s.</span>

<span class="sd">        We use Jerrum&#39;s filter in our implementation of the</span>
<span class="sd">        Schreier-Sims algorithm. It runs in polynomial time.</span>

<span class="sd">        This implementation is a translation of the C++ implementation in</span>
<span class="sd">        http://www.m8j.net</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.schreier_sims()</span>
<span class="sd">        &gt;&gt;&gt; G.stabilizers_gens()</span>
<span class="sd">        [[0, 2, 1]]</span>
<span class="sd">        &gt;&gt;&gt; G.coset_repr()</span>
<span class="sd">        [[[0, 1, 2], [1, 0, 2], [2, 0, 1]], [[0, 1, 2], [0, 2, 1]]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">JGr</span> <span class="o">=</span> <span class="n">_JGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">JGr</span><span class="o">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">coset_repr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_generators</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">generators</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">JGr</span><span class="o">.</span><span class="n">gens</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">JGr</span><span class="o">.</span><span class="n">gens</span><span class="p">))</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr_n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
            <span class="n">JGr</span><span class="o">.</span><span class="n">schreier_tree</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">gen</span><span class="p">)</span>
            <span class="n">cri</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">:</span>
                    <span class="n">cri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">perm_af_invert</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
            <span class="n">JGr</span><span class="o">.</span><span class="n">jerrum_filter</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">cri</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr_n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">base</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr_n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr_n</span>
            <span class="n">coset_repr</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span> <span class="k">if</span> <span class="n">p</span><span class="p">])</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">alpha</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">num_generators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">JGr</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">JGr</span><span class="o">.</span><span class="n">r</span><span class="p">:</span>
                <span class="n">generators</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">JGr</span><span class="o">.</span><span class="n">gens</span><span class="p">[:</span><span class="n">JGr</span><span class="o">.</span><span class="n">r</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">JGr</span><span class="o">.</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">alpha</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span> <span class="o">=</span> <span class="n">coset_repr</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">generators</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stabilizers_gens</span> <span class="o">=</span> <span class="n">a</span>

        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">JGr</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">JGr</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">JGr</span><span class="o">.</span><span class="n">gens</span> <span class="o">=</span> <span class="n">JGr</span><span class="o">.</span><span class="n">gens</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr_n</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">strong_gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stabilizers_gens</span><span class="p">:</span>
            <span class="n">gen</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gen</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">strong_gens</span><span class="p">:</span>
                <span class="n">strong_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strong_gens</span> <span class="o">=</span> <span class="n">strong_gens</span>
        <span class="n">base_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base</span><span class="p">)</span>
        <span class="n">transversals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">base_len</span>
        <span class="n">basic_orbits</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">base_len</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">base_len</span><span class="p">):</span>
            <span class="n">transversals</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">base_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span><span class="p">[</span><span class="n">base_point</span><span class="p">][:]</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">trans</span><span class="p">:</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                <span class="n">orbit_member</span> <span class="o">=</span> <span class="n">el</span><span class="p">(</span><span class="n">base_point</span><span class="p">)</span>
                <span class="n">transversals</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">orbit_member</span><span class="p">]</span> <span class="o">=</span> <span class="n">el</span>
            <span class="n">basic_orbits</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>\
            <span class="n">transversals</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span> <span class="o">=</span> <span class="n">transversals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_basic_orbits</span> <span class="o">=</span> <span class="n">basic_orbits</span>
</div>
<div class="viewcode-block" id="PermutationGroup.schreier_sims_random"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_random">[docs]</a>    <span class="k">def</span> <span class="nf">schreier_sims_random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">gens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">consec_succ</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>\
                             <span class="n">_random_prec</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Randomized Schreier-Sims algorithm.</span>

<span class="sd">        The randomized Schreier-Sims algorithm takes the sequence ``base``</span>
<span class="sd">        and the generating set ``gens``, and extends ``base`` to a base, and</span>
<span class="sd">        ``gens`` to a strong generating set relative to that base with</span>
<span class="sd">        probability of a wrong answer at most `1/\text{consec_succ}`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        ``base`` - the sequence to be extended to a base</span>
<span class="sd">        ``gens`` - the generating set to be extended to a strong generating set</span>
<span class="sd">        ``consec_succ`` - parameter defining the probability of a wrong answer.</span>
<span class="sd">        ``_random_prec`` - internal parameter used for testing purposes</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        ``(base, strong_gens)``, where ``base`` is the base and ``strong_gens``</span>
<span class="sd">        is the strong generating set relative to it.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.util import _verify_bsgs</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; base, strong_gens = S.schreier_sims_random(consec_succ=5)</span>
<span class="sd">        &gt;&gt;&gt; _verify_bsgs(S, base, strong_gens) #doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The algorithm is described in detail in [1],pp.97-98. It extends</span>
<span class="sd">        the orbits ``orbs`` and the permutation groups ``stabs`` to</span>
<span class="sd">        basic orbits and basic stabilizers for the base and strong generating</span>
<span class="sd">        set produced in the end.</span>
<span class="sd">        The idea of the extension process</span>
<span class="sd">        is to &quot;sift&quot; random group elements through the stabilizer chain</span>
<span class="sd">        and amend the stabilizers/orbits along the way when a sift</span>
<span class="sd">        is not successful.</span>
<span class="sd">        The helper function ``_strip`` is used to attempt</span>
<span class="sd">        to decompose a random group element according to the current</span>
<span class="sd">        state of the stabilizer chain and report whether the element was</span>
<span class="sd">        fully decomposed (successful sift) or not (unsuccessful sift). In</span>
<span class="sd">        the latter case, the level at which the sift failed is reported and</span>
<span class="sd">        used to amend ``stabs``, ``base``, ``gens`` and ``orbs`` accordingly.</span>
<span class="sd">        The halting condition is for ``consec_succ`` consecutive successful</span>
<span class="sd">        sifts to pass. This makes sure that the current ``base`` and ``gens``</span>
<span class="sd">        form a BSGS with probability at least `1 - 1/\text{consec_succ}`.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        schreier_sims</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">gens</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="n">base_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="c"># make sure no generator fixes all base points</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">[</span><span class="n">gen</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">base</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">base</span><span class="p">]:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">gen</span><span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="o">==</span> <span class="n">new</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="n">base_len</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c"># distribute generators according to basic stabilizers</span>
        <span class="n">distr_gens</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">gens</span><span class="p">)</span>
        <span class="c"># initialize the basic stabilizers, basic transversals and basic orbits</span>
        <span class="n">stabs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">transversals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">base_len</span><span class="p">):</span>
            <span class="n">stabs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">distr_gens</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">stabs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">orbit_transversal</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>\
                                                              <span class="n">pairs</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
            <span class="n">orbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c"># initialize the number of consecutive elements sifted</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># start sifting random elements while the number of consecutive sifts</span>
        <span class="c"># is less than consec_succ</span>
        <span class="k">while</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">consec_succ</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_random_prec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">_strip</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">transversals</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c"># determine whether a new base point is needed</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">base_len</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">h</span><span class="o">.</span><span class="n">is_Identity</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">moved</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">h</span><span class="p">(</span><span class="n">moved</span><span class="p">)</span> <span class="o">==</span> <span class="n">moved</span><span class="p">:</span>
                    <span class="n">moved</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moved</span><span class="p">)</span>
                <span class="n">base_len</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">distr_gens</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c"># if the element doesn&#39;t sift, amend the strong generators and</span>
            <span class="c"># associated stabilizers and orbits</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                    <span class="n">distr_gens</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                    <span class="n">stabs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">distr_gens</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                    <span class="n">transversals</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">stabs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">orbit_transversal</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">],</span>\
                                                                    <span class="n">pairs</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                    <span class="n">orbs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c"># build the strong generating set</span>
        <span class="n">strong_gens</span> <span class="o">=</span> <span class="n">distr_gens</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">distr_gens</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">gen</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">strong_gens</span><span class="p">:</span>
                <span class="n">strong_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span>
</div>
<div class="viewcode-block" id="PermutationGroup.schreier_vector"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.schreier_vector">[docs]</a>    <span class="k">def</span> <span class="nf">schreier_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the schreier vector for ``alpha``.</span>

<span class="sd">        The Schreier vector efficiently stores information</span>
<span class="sd">        about the orbit of ``alpha``. It can later be used to quickly obtain</span>
<span class="sd">        elements of the group that send ``alpha`` to a particular element</span>
<span class="sd">        in the orbit. Notice that the Schreier vector depends on the order</span>
<span class="sd">        in which the group generators are listed. For a definition, see [3].</span>
<span class="sd">        Since list indices start from zero, we adopt the convention to use</span>
<span class="sd">        &quot;None&quot; instead of 0 to signify that an element doesn&#39;t belong</span>
<span class="sd">        to the orbit.</span>
<span class="sd">        For the algorithm and its correctness, see [2], pp.78-80.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([2,4,6,3,1,5,0])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0,1,3,5,4,6,2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a,b])</span>
<span class="sd">        &gt;&gt;&gt; G.schreier_vector(0)</span>
<span class="sd">        [-1, None, 0, 1, None, 1, 0]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        orbit</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">v</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">orb</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
        <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">used</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                    <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">v</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">v</span>
</div>
<div class="viewcode-block" id="PermutationGroup.stabilizer"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.stabilizer">[docs]</a>    <span class="k">def</span> <span class="nf">stabilizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Returns the stabilizer subgroup of ``alpha``.</span>

<span class="sd">        The stabilizer of `\alpha` is the group `G_\alpha =</span>
<span class="sd">        \{g \in G | g(\alpha) = \alpha\}`.</span>
<span class="sd">        For a proof of correctness, see [1], p.79.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; G = DihedralGroup(6)</span>
<span class="sd">        &gt;&gt;&gt; G.stabilizer(5)</span>
<span class="sd">        PermutationGroup([Permutation([4, 3, 2, 1, 0, 5]),</span>
<span class="sd">        Permutation([0, 1, 2, 3, 4, 5])])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        orbit</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">orb</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
        <span class="n">table</span> <span class="o">=</span> <span class="p">{</span><span class="n">alpha</span><span class="p">:</span> <span class="n">_new_from_array_form</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))}</span>
        <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">used</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="n">stab_gens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">gen</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">gen_temp</span> <span class="o">=</span> <span class="n">gen</span><span class="o">*</span><span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                    <span class="n">orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="n">gen_temp</span>
                    <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">schreier_gen</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">table</span><span class="p">[</span><span class="n">temp</span><span class="p">])</span><span class="o">*</span><span class="n">gen</span><span class="o">*</span><span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">schreier_gen</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stab_gens</span><span class="p">:</span>
                        <span class="n">stab_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">schreier_gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">stab_gens</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="PermutationGroup.stabilizers_gens"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.stabilizers_gens">[docs]</a>    <span class="k">def</span> <span class="nf">stabilizers_gens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Schreier-Sims stabilizers generators</span>

<span class="sd">        Return the generators of the stabilizers chain in the</span>
<span class="sd">        Schreier-Sims representation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.stabilizers_gens()</span>
<span class="sd">        [[0, 2, 1]]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_repr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stabilizers_gens</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.strong_gens"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.strong_gens">[docs]</a>    <span class="k">def</span> <span class="nf">strong_gens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a strong generating set from the Schreier-Sims algorithm.</span>

<span class="sd">        A generating set `S = \{g_1, g_2, ..., g_t\}` for a permutation group</span>
<span class="sd">        `G` is a strong generating set relative to the sequence of points</span>
<span class="sd">        (referred to as a &quot;base&quot;) `(b_1, b_2, ..., b_k)` if, for</span>
<span class="sd">        `1 \leq i \leq k` we have that the intersection of the pointwise</span>
<span class="sd">        stabilizer `G^{(i+1)} := G_{b_1, b_2, ..., b_i}` with `S` generates</span>
<span class="sd">        the pointwise stabilizer `G^{(i+1)}`. The concepts of a base and</span>
<span class="sd">        strong generating set and their applications are discussed in depth</span>
<span class="sd">        in [1],pp.87-89 and [2],pp.55-57.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; D = DihedralGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; D.strong_gens</span>
<span class="sd">        [Permutation([1, 2, 3, 0]), Permutation([3, 2, 1, 0]),\</span>
<span class="sd">        Permutation([0, 3, 2, 1])]</span>
<span class="sd">        &gt;&gt;&gt; D.base</span>
<span class="sd">        [0, 1]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        base, basic_transversals, basic_orbits, basic_stabilizers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strong_gens</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strong_gens</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.transitivity_degree"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.transitivity_degree">[docs]</a>    <span class="k">def</span> <span class="nf">transitivity_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the degree of transitivity of the group.</span>

<span class="sd">        A permutation group `G` acting on `\Omega = \{0, 2, ..., n-1\}` is</span>
<span class="sd">        `k`-fold transitive, if, for any k points</span>
<span class="sd">        `(a_1, a_2, ..., a_k)\in\Omega` and any k points</span>
<span class="sd">        `(b_1, b_2, ..., b_k)\in\Omega` there exists `g\in G` such that</span>
<span class="sd">        `g(a_1)=b_1, g(a_2)=b_2, ..., g(a_k)=b_k`</span>
<span class="sd">        The degree of transitivity of `G` is the maximum `k` such that</span>
<span class="sd">        `G` is `k`-fold transitive. ([8])</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1, 2, 0])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a,b])</span>
<span class="sd">        &gt;&gt;&gt; G.transitivity_degree</span>
<span class="sd">        3</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        is_transitive, orbit</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transitivity_degree</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="n">max_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">max_size</span> <span class="o">*=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s">&#39;tuples&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">max_size</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transitivity_degree</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transitivity_degree</span>

</div></div>
<span class="k">def</span> <span class="nf">DirectProduct</span><span class="p">(</span><span class="o">*</span><span class="n">groups</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the direct product of several groups as a permutation group.</span>

<span class="sd">    This is implemented much like the __mul__ procedure for taking the direct</span>
<span class="sd">    product of two permutation groups, but the idea of shifting the</span>
<span class="sd">    generators is realized in the case of an arbitrary number of groups.</span>
<span class="sd">    A call to DirectProduct(G1, G2, ..., Gn) is generally expected to be faster</span>
<span class="sd">    than a call to G1*G2*...*Gn (and thus the need for this algorithm).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.perm_groups import DirectProduct</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.named_groups import CyclicGroup</span>
<span class="sd">    &gt;&gt;&gt; C = CyclicGroup(4)</span>
<span class="sd">    &gt;&gt;&gt; G = DirectProduct(C,C,C)</span>
<span class="sd">    &gt;&gt;&gt; G.order()</span>
<span class="sd">    64</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    __mul__</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">degrees</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gens_count</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_degree</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_gens</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="n">current_deg</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">current_num_gens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">generators</span><span class="p">)</span>
        <span class="n">degrees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_deg</span><span class="p">)</span>
        <span class="n">total_degree</span> <span class="o">+=</span> <span class="n">current_deg</span>
        <span class="n">gens_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_num_gens</span><span class="p">)</span>
        <span class="n">total_gens</span> <span class="o">+=</span> <span class="n">current_num_gens</span>
    <span class="n">array_gens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_gens</span><span class="p">):</span>
        <span class="n">array_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">total_degree</span><span class="p">))</span>
    <span class="n">current_gen</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">current_deg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gens_count</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">current_gen</span><span class="p">,</span> <span class="n">current_gen</span> <span class="o">+</span> <span class="n">gens_count</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">gen</span> <span class="o">=</span> <span class="p">((</span><span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">generators</span><span class="p">)[</span><span class="n">j</span> <span class="o">-</span> <span class="n">current_gen</span><span class="p">])</span><span class="o">.</span><span class="n">array_form</span>
            <span class="n">array_gens</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">current_deg</span><span class="p">:</span><span class="n">current_deg</span> <span class="o">+</span> <span class="n">degrees</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span>\
            <span class="p">[</span> <span class="n">x</span> <span class="o">+</span> <span class="n">current_deg</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">]</span>
        <span class="n">current_gen</span> <span class="o">+=</span> <span class="n">gens_count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">current_deg</span> <span class="o">+=</span> <span class="n">degrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">perm_gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">_new_from_array_form</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">array_gens</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">perm_gens</span><span class="p">)</span>

<span class="n">PermGroup</span> <span class="o">=</span> <span class="n">PermutationGroup</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.1-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li>
          <li><a href="../combinatorics.html" >sympy.combinatorics</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, 2009, 2010, 2011, 2012 SymPy Development Team.
      Last updated on Aug 04, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>